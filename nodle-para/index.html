<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://polkascan.github.io/py-substrate-interface/nodle-para/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Nodle - PySubstrate metadata docs</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Nodle";
        var mkdocs_page_input_path = "nodle-para.md";
        var mkdocs_page_url = "/py-substrate-interface/nodle-para/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> PySubstrate metadata docs
        </a>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Overview</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Polkadot Ecosystem Runtimes</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../polkadot/">Polkadot</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../statemint/">Statemint</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../collectives/">Collectives</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../moonbeam/">Moonbeam</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../acala/">Acala</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ajuna/">Ajuna Polkadot</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../astar/">Astar</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../darwinia-parachain/">Darwinia Parachain</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../bifrost_polkadot/">Bifrost Polkadot</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../bitgreen-parachain/">Bitgreen</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../centrifuge/">Centrifuge</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../clover-mainnet/">Clover</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../composable/">Composable Finance</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../efinity/">Efinity</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../equilibrium-parachain/">Equilibrium parachain</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../frequency/">Frequency</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../hashed/">Hashed Network</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../hydradx/">HydraDX</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../integritee-parachain/">Integritee Shell</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../interlay-parachain/">Interlay</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../totem-parachain/">Kapex</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../kilt-spiritnet/">KILT Spiritnet</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../kylin/">Kylin Network</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../litentry-parachain/">Litentry</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">Nodle</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#system">System</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#fill_block">fill_block</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#remark">remark</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set_heap_pages">set_heap_pages</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set_code">set_code</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set_code_without_checks">set_code_without_checks</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set_storage">set_storage</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#kill_storage">kill_storage</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#kill_prefix">kill_prefix</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#remark_with_event">remark_with_event</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#extrinsicsuccess">ExtrinsicSuccess</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#extrinsicfailed">ExtrinsicFailed</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#codeupdated">CodeUpdated</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#newaccount">NewAccount</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#killedaccount">KilledAccount</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#remarked">Remarked</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#account">Account</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#extrinsiccount">ExtrinsicCount</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#blockweight">BlockWeight</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#allextrinsicslen">AllExtrinsicsLen</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#blockhash">BlockHash</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#extrinsicdata">ExtrinsicData</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#number">Number</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#parenthash">ParentHash</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#digest">Digest</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#events_1">Events</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#eventcount">EventCount</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#eventtopics">EventTopics</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#lastruntimeupgrade">LastRuntimeUpgrade</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#upgradedtou32refcount">UpgradedToU32RefCount</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#upgradedtotriplerefcount">UpgradedToTripleRefCount</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#executionphase">ExecutionPhase</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#constants">Constants</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#blockweights">BlockWeights</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#blocklength">BlockLength</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#blockhashcount">BlockHashCount</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#dbweight">DbWeight</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#version">Version</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ss58prefix">SS58Prefix</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#invalidspecname">InvalidSpecName</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#specversionneedstoincrease">SpecVersionNeedsToIncrease</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#failedtoextractruntimeversion">FailedToExtractRuntimeVersion</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#nondefaultcomposite">NonDefaultComposite</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#nonzerorefcount">NonZeroRefCount</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#callfiltered">CallFiltered</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#timestamp">Timestamp</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_1">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#set">set</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_1">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#now">Now</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#didupdate">DidUpdate</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#constants_1">Constants</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#minimumperiod">MinimumPeriod</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#balances">Balances</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_2">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#transfer">transfer</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set_balance">set_balance</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#force_transfer">force_transfer</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#transfer_keep_alive">transfer_keep_alive</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#transfer_all">transfer_all</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#force_unreserve">force_unreserve</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_2">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#endowed">Endowed</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#dustlost">DustLost</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#transfer_1">Transfer</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#balanceset">BalanceSet</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#reserved">Reserved</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unreserved">Unreserved</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#reserverepatriated">ReserveRepatriated</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#deposit">Deposit</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#withdraw">Withdraw</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#slashed">Slashed</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_2">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#totalissuance">TotalIssuance</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#account_1">Account</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#locks">Locks</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#reserves">Reserves</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#storageversion">StorageVersion</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#constants_2">Constants</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#existentialdeposit">ExistentialDeposit</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#maxlocks">MaxLocks</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#maxreserves">MaxReserves</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors_1">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#vestingbalance">VestingBalance</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#liquidityrestrictions">LiquidityRestrictions</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#insufficientbalance">InsufficientBalance</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#existentialdeposit_1">ExistentialDeposit</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#keepalive">KeepAlive</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#existingvestingschedule">ExistingVestingSchedule</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#deadaccount">DeadAccount</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#toomanyreserves">TooManyReserves</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#transactionpayment">TransactionPayment</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#events_3">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#transactionfeepaid">TransactionFeePaid</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_3">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#nextfeemultiplier">NextFeeMultiplier</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#storageversion_1">StorageVersion</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#constants_3">Constants</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#operationalfeemultiplier">OperationalFeeMultiplier</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#randomnesscollectiveflip">RandomnessCollectiveFlip</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_4">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#randommaterial">RandomMaterial</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#scheduler">Scheduler</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_3">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#schedule">schedule</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cancel">cancel</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#schedule_named">schedule_named</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cancel_named">cancel_named</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#schedule_after">schedule_after</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#schedule_named_after">schedule_named_after</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_4">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#scheduled">Scheduled</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#canceled">Canceled</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#dispatched">Dispatched</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#calllookupfailed">CallLookupFailed</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_5">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#agenda">Agenda</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#lookup">Lookup</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#constants_4">Constants</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#maximumweight">MaximumWeight</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#maxscheduledperblock">MaxScheduledPerBlock</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors_2">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#failedtoschedule">FailedToSchedule</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#notfound">NotFound</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#targetblocknumberinpast">TargetBlockNumberInPast</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#reschedulenochange">RescheduleNoChange</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#companyreserve">CompanyReserve</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_4">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#spend">spend</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#tip">tip</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#apply_as">apply_as</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_5">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#deposit_1">Deposit</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#spentfunds">SpentFunds</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#tipreceived">TipReceived</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#reserveop">ReserveOp</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#internationalreserve">InternationalReserve</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_5">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#spend_1">spend</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#tip_1">tip</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#apply_as_1">apply_as</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_6">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#deposit_2">Deposit</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#spentfunds_1">SpentFunds</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#tipreceived_1">TipReceived</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#reserveop_1">ReserveOp</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#usareserve">UsaReserve</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_6">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#spend_2">spend</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#tip_2">tip</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#apply_as_2">apply_as</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_7">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#deposit_3">Deposit</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#spentfunds_2">SpentFunds</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#tipreceived_2">TipReceived</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#reserveop_2">ReserveOp</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#vesting">Vesting</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_7">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#claim">claim</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#add_vesting_schedule">add_vesting_schedule</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cancel_all_vesting_schedules">cancel_all_vesting_schedules</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_8">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#vestingscheduleadded">VestingScheduleAdded</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#claimed">Claimed</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#vestingschedulescanceled">VestingSchedulesCanceled</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_6">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#vestingschedules">VestingSchedules</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#counterforvestingschedules">CounterForVestingSchedules</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#storageversion_2">StorageVersion</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#constants_5">Constants</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#maxschedule">MaxSchedule</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors_3">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#zerovestingperiod">ZeroVestingPeriod</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#zerovestingperiodcount">ZeroVestingPeriodCount</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#numoverflow">NumOverflow</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#insufficientbalancetolock">InsufficientBalanceToLock</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#emptyschedules">EmptySchedules</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#vestingtoself">VestingToSelf</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#maxscheduleoverflow">MaxScheduleOverflow</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#mandate">Mandate</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_8">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#apply">apply</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_9">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#rootop">RootOp</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#technicalcommittee">TechnicalCommittee</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_9">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#set_members">set_members</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#execute">execute</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#propose">propose</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#vote">vote</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#close">close</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#disapprove_proposal">disapprove_proposal</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_10">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#proposed">Proposed</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#voted">Voted</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#approved">Approved</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#disapproved">Disapproved</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#executed">Executed</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#memberexecuted">MemberExecuted</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#closed">Closed</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_7">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#proposals">Proposals</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#proposalof">ProposalOf</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#voting">Voting</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#proposalcount">ProposalCount</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#members">Members</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#prime">Prime</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors_4">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#notmember">NotMember</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#duplicateproposal">DuplicateProposal</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#proposalmissing">ProposalMissing</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#wrongindex">WrongIndex</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#duplicatevote">DuplicateVote</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#alreadyinitialized">AlreadyInitialized</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#tooearly">TooEarly</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#toomanyproposals">TooManyProposals</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#wrongproposalweight">WrongProposalWeight</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#wrongproposallength">WrongProposalLength</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#technicalmembership">TechnicalMembership</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_10">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#add_member">add_member</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#remove_member">remove_member</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#swap_member">swap_member</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#reset_members">reset_members</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#change_key">change_key</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set_prime">set_prime</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#clear_prime">clear_prime</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_11">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#memberadded">MemberAdded</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#memberremoved">MemberRemoved</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#membersswapped">MembersSwapped</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#membersreset">MembersReset</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#keychanged">KeyChanged</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#dummy">Dummy</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_8">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#members_1">Members</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#prime_1">Prime</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors_5">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#alreadymember">AlreadyMember</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#notmember_1">NotMember</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#toomanymembers">TooManyMembers</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#authorship">Authorship</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_11">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#set_uncles">set_uncles</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_9">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#uncles">Uncles</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#author">Author</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#didsetuncles">DidSetUncles</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#constants_6">Constants</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#unclegenerations">UncleGenerations</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors_6">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#invaliduncleparent">InvalidUncleParent</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unclesalreadyset">UnclesAlreadySet</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#toomanyuncles">TooManyUncles</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#genesisuncle">GenesisUncle</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#toohighuncle">TooHighUncle</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unclealreadyincluded">UncleAlreadyIncluded</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#olduncle">OldUncle</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#validatorsset">ValidatorsSet</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_12">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#add_member_1">add_member</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#remove_member_1">remove_member</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#swap_member_1">swap_member</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#reset_members_1">reset_members</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#change_key_1">change_key</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set_prime_1">set_prime</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#clear_prime_1">clear_prime</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_12">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#memberadded_1">MemberAdded</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#memberremoved_1">MemberRemoved</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#membersswapped_1">MembersSwapped</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#membersreset_1">MembersReset</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#keychanged_1">KeyChanged</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#dummy_1">Dummy</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_10">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#members_2">Members</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#prime_2">Prime</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors_7">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#alreadymember_1">AlreadyMember</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#notmember_2">NotMember</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#toomanymembers_1">TooManyMembers</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#poa">Poa</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_11">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#storageversion_3">StorageVersion</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#session">Session</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_13">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#set_keys">set_keys</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#purge_keys">purge_keys</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_13">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#newsession">NewSession</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_12">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#validators">Validators</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#currentindex">CurrentIndex</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#queuedchanged">QueuedChanged</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#queuedkeys">QueuedKeys</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#disabledvalidators">DisabledValidators</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#nextkeys">NextKeys</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#keyowner">KeyOwner</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors_8">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#invalidproof">InvalidProof</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#noassociatedvalidatorid">NoAssociatedValidatorId</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#duplicatedkey">DuplicatedKey</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#nokeys">NoKeys</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#noaccount">NoAccount</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#aura">Aura</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_13">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#authorities">Authorities</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#currentslot">CurrentSlot</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#auraext">AuraExt</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_14">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#authorities_1">Authorities</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#parachainsystem">ParachainSystem</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_14">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#set_validation_data">set_validation_data</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#sudo_send_upward_message">sudo_send_upward_message</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#authorize_upgrade">authorize_upgrade</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#enact_authorized_upgrade">enact_authorized_upgrade</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_14">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#validationfunctionstored">ValidationFunctionStored</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#validationfunctionapplied">ValidationFunctionApplied</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#validationfunctiondiscarded">ValidationFunctionDiscarded</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#upgradeauthorized">UpgradeAuthorized</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#downwardmessagesreceived">DownwardMessagesReceived</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#downwardmessagesprocessed">DownwardMessagesProcessed</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_15">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#pendingvalidationcode">PendingValidationCode</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#newvalidationcode">NewValidationCode</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#validationdata">ValidationData</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#didsetvalidationcode">DidSetValidationCode</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#lastrelaychainblocknumber">LastRelayChainBlockNumber</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#upgraderestrictionsignal">UpgradeRestrictionSignal</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#relaystateproof">RelayStateProof</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#relevantmessagingstate">RelevantMessagingState</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#hostconfiguration">HostConfiguration</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#lastdmqmqchead">LastDmqMqcHead</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#lasthrmpmqcheads">LastHrmpMqcHeads</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#processeddownwardmessages">ProcessedDownwardMessages</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#hrmpwatermark">HrmpWatermark</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#hrmpoutboundmessages">HrmpOutboundMessages</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#upwardmessages">UpwardMessages</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#pendingupwardmessages">PendingUpwardMessages</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#announcedhrmpmessagespercandidate">AnnouncedHrmpMessagesPerCandidate</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#reservedxcmpweightoverride">ReservedXcmpWeightOverride</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#reserveddmpweightoverride">ReservedDmpWeightOverride</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#authorizedupgrade">AuthorizedUpgrade</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#customvalidationheaddata">CustomValidationHeadData</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors_9">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#overlappingupgrades">OverlappingUpgrades</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#prohibitedbypolkadot">ProhibitedByPolkadot</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#toobig">TooBig</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#validationdatanotavailable">ValidationDataNotAvailable</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#hostconfigurationnotavailable">HostConfigurationNotAvailable</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#notscheduled">NotScheduled</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#nothingauthorized">NothingAuthorized</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unauthorized">Unauthorized</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#parachaininfo">ParachainInfo</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_16">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#parachainid">ParachainId</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cumulusxcm">CumulusXcm</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#events_15">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#invalidformat">InvalidFormat</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unsupportedversion">UnsupportedVersion</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#executeddownward">ExecutedDownward</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#utility">Utility</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_15">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#batch">batch</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#as_derivative">as_derivative</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#batch_all">batch_all</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#dispatch_as">dispatch_as</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#force_batch">force_batch</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_16">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#batchinterrupted">BatchInterrupted</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#batchcompleted">BatchCompleted</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#batchcompletedwitherrors">BatchCompletedWithErrors</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#itemcompleted">ItemCompleted</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#itemfailed">ItemFailed</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#dispatchedas">DispatchedAs</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#constants_7">Constants</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#batched_calls_limit">batched_calls_limit</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors_10">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#toomanycalls">TooManyCalls</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#multisig">Multisig</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_16">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#as_multi_threshold_1">as_multi_threshold_1</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#as_multi">as_multi</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#approve_as_multi">approve_as_multi</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cancel_as_multi">cancel_as_multi</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_17">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#newmultisig">NewMultisig</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#multisigapproval">MultisigApproval</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#multisigexecuted">MultisigExecuted</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#multisigcancelled">MultisigCancelled</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_17">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#multisigs">Multisigs</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#calls_17">Calls</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#constants_8">Constants</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#depositbase">DepositBase</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#depositfactor">DepositFactor</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#maxsignatories">MaxSignatories</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors_11">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#minimumthreshold">MinimumThreshold</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#alreadyapproved">AlreadyApproved</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#noapprovalsneeded">NoApprovalsNeeded</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#toofewsignatories">TooFewSignatories</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#toomanysignatories">TooManySignatories</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#signatoriesoutoforder">SignatoriesOutOfOrder</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#senderinsignatories">SenderInSignatories</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#notfound_1">NotFound</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#notowner">NotOwner</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#notimepoint">NoTimepoint</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#wrongtimepoint">WrongTimepoint</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unexpectedtimepoint">UnexpectedTimepoint</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#maxweighttoolow">MaxWeightTooLow</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#alreadystored">AlreadyStored</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#uniques">Uniques</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_18">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#create">create</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#force_create">force_create</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#destroy">destroy</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#mint">mint</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#burn">burn</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#transfer_2">transfer</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#redeposit">redeposit</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#freeze">freeze</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#thaw">thaw</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#freeze_collection">freeze_collection</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#thaw_collection">thaw_collection</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#transfer_ownership">transfer_ownership</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set_team">set_team</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#approve_transfer">approve_transfer</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cancel_approval">cancel_approval</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#force_item_status">force_item_status</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set_attribute">set_attribute</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#clear_attribute">clear_attribute</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set_metadata">set_metadata</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#clear_metadata">clear_metadata</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set_collection_metadata">set_collection_metadata</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#clear_collection_metadata">clear_collection_metadata</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set_accept_ownership">set_accept_ownership</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set_collection_max_supply">set_collection_max_supply</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_18">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#created">Created</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#forcecreated">ForceCreated</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#destroyed">Destroyed</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#issued">Issued</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#transferred">Transferred</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#burned">Burned</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#frozen">Frozen</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#thawed">Thawed</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#collectionfrozen">CollectionFrozen</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#collectionthawed">CollectionThawed</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ownerchanged">OwnerChanged</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#teamchanged">TeamChanged</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#approvedtransfer">ApprovedTransfer</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#approvalcancelled">ApprovalCancelled</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#itemstatuschanged">ItemStatusChanged</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#collectionmetadataset">CollectionMetadataSet</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#collectionmetadatacleared">CollectionMetadataCleared</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#metadataset">MetadataSet</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#metadatacleared">MetadataCleared</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#redeposited">Redeposited</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#attributeset">AttributeSet</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#attributecleared">AttributeCleared</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ownershipacceptancechanged">OwnershipAcceptanceChanged</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#collectionmaxsupplyset">CollectionMaxSupplySet</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_18">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#class">Class</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ownershipacceptance">OwnershipAcceptance</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#account_2">Account</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#classaccount">ClassAccount</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#asset">Asset</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#classmetadataof">ClassMetadataOf</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#instancemetadataof">InstanceMetadataOf</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#attribute">Attribute</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#collectionmaxsupply">CollectionMaxSupply</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#constants_9">Constants</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#collectiondeposit">CollectionDeposit</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#itemdeposit">ItemDeposit</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#metadatadepositbase">MetadataDepositBase</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#attributedepositbase">AttributeDepositBase</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#depositperbyte">DepositPerByte</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#stringlimit">StringLimit</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#keylimit">KeyLimit</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#valuelimit">ValueLimit</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors_12">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#nopermission">NoPermission</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unknowncollection">UnknownCollection</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#alreadyexists">AlreadyExists</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#wrongowner">WrongOwner</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#badwitness">BadWitness</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#inuse">InUse</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#frozen_1">Frozen</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#wrongdelegate">WrongDelegate</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#nodelegate">NoDelegate</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unapproved">Unapproved</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unaccepted">Unaccepted</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#locked">Locked</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#maxsupplyreached">MaxSupplyReached</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#maxsupplyalreadyset">MaxSupplyAlreadySet</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#maxsupplytoosmall">MaxSupplyTooSmall</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#preimage">Preimage</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_19">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#note_preimage">note_preimage</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unnote_preimage">unnote_preimage</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#request_preimage">request_preimage</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unrequest_preimage">unrequest_preimage</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_19">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#noted">Noted</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#requested">Requested</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cleared">Cleared</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_19">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#statusfor">StatusFor</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#preimagefor">PreimageFor</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors_13">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#toolarge">TooLarge</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#alreadynoted">AlreadyNoted</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#notauthorized">NotAuthorized</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#notnoted">NotNoted</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#requested_1">Requested</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#notrequested">NotRequested</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#allocations">Allocations</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_20">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#batch_1">batch</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_20">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#storageversion_4">StorageVersion</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#constants_10">Constants</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#protocolfee">ProtocolFee</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#maximumsupply">MaximumSupply</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#existentialdeposit_2">ExistentialDeposit</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#maxallocs">MaxAllocs</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors_14">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#oracleaccessdenied">OracleAccessDenied</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#toomanycoinstoallocate">TooManyCoinsToAllocate</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#doesnotsatisfyexistentialdeposit">DoesNotSatisfyExistentialDeposit</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#batchempty">BatchEmpty</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#allocationsoracles">AllocationsOracles</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#calls_21">Calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#add_member_2">add_member</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#remove_member_2">remove_member</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#swap_member_2">swap_member</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#reset_members_2">reset_members</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#change_key_2">change_key</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set_prime_2">set_prime</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#clear_prime_2">clear_prime</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#events_20">Events</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#memberadded_2">MemberAdded</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#memberremoved_2">MemberRemoved</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#membersswapped_2">MembersSwapped</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#membersreset_2">MembersReset</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#keychanged_2">KeyChanged</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#dummy_2">Dummy</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#storage-functions_21">Storage functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#members_3">Members</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#prime_3">Prime</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#errors_15">Errors</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#alreadymember_2">AlreadyMember</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#notmember_3">NotMember</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#toomanymembers_2">TooManyMembers</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../origintrail-parachain/">OriginTrail Parachain</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../parallel/">Parallel</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../phala/">Phala</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../unique/">UNIQUE</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Kusama Ecosystem Runtimes</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../kusama/">Kusama</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../statemine/">Statemine</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../altair/">Altair</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../amplitude/">Amplitude</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../bajun/">Bajun Kusama</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basilisk/">Basilisk</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../bifrost/">Bifrost</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../dora-ksm-parachain/">Dorafactory Network</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../calamari/">Calamari Parachain</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../crust-collator/">Crust Shadow</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ipci/">Ipci</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../crab-parachain/">Crab Parachain</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../imbue/">imbue kusama</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../integritee-parachain/">Integritee Network (Kusama)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../kabocha-parachain/">Kabocha</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../karura/">Karura</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../khala/">Khala</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../kico/">KICO</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../kintsugi-parachain/">kintsugi</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../listen-parachain/">Listen Network</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../litmus-parachain/">Litmus</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mangata-parachain/">Mangata Kusama Mainnet</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../moonriver/">Moonriver</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../heiko/">Parallel Heiko</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../picasso/">Picasso</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../pichiu/">Pichiu Network</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../pioneer-runtime/">Pioneer Network</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../quartz/">QUARTZ by UNIQUE</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../parachain-rio/">Rio Kusama Mainnet</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../robonomics/">Robonomics</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../snow/">Snow Kusama</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../shiden/">Shiden</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../sora_ksm/">SORA Kusama</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../subsocial-parachain/">SubsocialX</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../turing/">Turing Network</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../zeitgeist/">Zeitgeist</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">PySubstrate metadata docs</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>Polkadot Ecosystem Runtimes &raquo;</li>
      <li>Nodle</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/polkascan/py-substrate-metadata-docs/edit/main/docs/nodle-para.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="nodle-para">nodle-para</h1>
<hr />
<table>
<thead>
<tr>
<th>Properties</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Spec name</td>
<td>nodle-para</td>
</tr>
<tr>
<td>Implementation name</td>
<td>nodle-para</td>
</tr>
<tr>
<td>Spec version</td>
<td>12</td>
</tr>
<tr>
<td>SS58 Format</td>
<td>37</td>
</tr>
<tr>
<td>Token symbol</td>
<td>NODL</td>
</tr>
<tr>
<td>Token decimals</td>
<td>11</td>
</tr>
</tbody>
</table>
<h2 id="system">System</h2>
<hr />
<h3 id="calls">Calls</h3>
<hr />
<h4 id="fill_block">fill_block</h4>
<p>A dispatch that will fill the block weight up to the given ratio.</p>
<h5 id="attributes">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>ratio</td>
<td><code>Perbill</code></td>
</tr>
</tbody>
</table>
<h5 id="python">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'System', 'fill_block', {'ratio': 'u32'}
)
</code></pre>
<hr />
<h4 id="remark">remark</h4>
<p>Make some on-chain remark.</p>
<p># &lt;weight&gt;
- <code>O(1)</code>
# &lt;/weight&gt;</p>
<h5 id="attributes_1">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>remark</td>
<td><code>Vec&lt;u8&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_1">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'System', 'remark', {'remark': 'Bytes'}
)
</code></pre>
<hr />
<h4 id="set_heap_pages">set_heap_pages</h4>
<p>Set the number of pages in the WebAssembly environment&amp;#x27;s heap.</p>
<h5 id="attributes_2">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>pages</td>
<td><code>u64</code></td>
</tr>
</tbody>
</table>
<h5 id="python_2">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'System', 'set_heap_pages', {'pages': 'u64'}
)
</code></pre>
<hr />
<h4 id="set_code">set_code</h4>
<p>Set the new runtime code.</p>
<p># &lt;weight&gt;
- <code>O(C + S)</code> where <code>C</code> length of <code>code</code> and <code>S</code> complexity of <code>can_set_code</code>
- 1 call to <code>can_set_code</code>: <code>O(S)</code> (calls <code>sp_io::misc::runtime_version</code> which is
  expensive).
- 1 storage write (codec <code>O(C)</code>).
- 1 digest item.
- 1 event.
The weight of this function is dependent on the runtime, but generally this is very
expensive. We will treat this as a full block.
# &lt;/weight&gt;</p>
<h5 id="attributes_3">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>code</td>
<td><code>Vec&lt;u8&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_3">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'System', 'set_code', {'code': 'Bytes'}
)
</code></pre>
<hr />
<h4 id="set_code_without_checks">set_code_without_checks</h4>
<p>Set the new runtime code without doing any checks of the given <code>code</code>.</p>
<p># &lt;weight&gt;
- <code>O(C)</code> where <code>C</code> length of <code>code</code>
- 1 storage write (codec <code>O(C)</code>).
- 1 digest item.
- 1 event.
The weight of this function is dependent on the runtime. We will treat this as a full
block. # &lt;/weight&gt;</p>
<h5 id="attributes_4">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>code</td>
<td><code>Vec&lt;u8&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_4">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'System', 'set_code_without_checks', {'code': 'Bytes'}
)
</code></pre>
<hr />
<h4 id="set_storage">set_storage</h4>
<p>Set some items of storage.</p>
<h5 id="attributes_5">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>items</td>
<td><code>Vec&lt;KeyValue&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_5">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'System', 'set_storage', {'items': [('Bytes', 'Bytes')]}
)
</code></pre>
<hr />
<h4 id="kill_storage">kill_storage</h4>
<p>Kill some items from storage.</p>
<h5 id="attributes_6">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>keys</td>
<td><code>Vec&lt;Key&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_6">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'System', 'kill_storage', {'keys': ['Bytes']}
)
</code></pre>
<hr />
<h4 id="kill_prefix">kill_prefix</h4>
<p>Kill all storage items with a key that starts with the given prefix.</p>
<p><strong>NOTE:</strong> We rely on the Root origin to provide us the number of subkeys under
the prefix we are removing to accurately calculate the weight of this function.</p>
<h5 id="attributes_7">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>prefix</td>
<td><code>Key</code></td>
</tr>
<tr>
<td>subkeys</td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<h5 id="python_7">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'System', 'kill_prefix', {'prefix': 'Bytes', 'subkeys': 'u32'}
)
</code></pre>
<hr />
<h4 id="remark_with_event">remark_with_event</h4>
<p>Make some on-chain remark and emit event.</p>
<h5 id="attributes_8">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>remark</td>
<td><code>Vec&lt;u8&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_8">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'System', 'remark_with_event', {'remark': 'Bytes'}
)
</code></pre>
<hr />
<h3 id="events">Events</h3>
<hr />
<h4 id="extrinsicsuccess">ExtrinsicSuccess</h4>
<p>An extrinsic completed successfully.</p>
<h5 id="attributes_9">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>dispatch_info</td>
<td><code>DispatchInfo</code></td>
<td><code>{'weight': 'u64', 'class': ('Normal', 'Operational', 'Mandatory'), 'pays_fee': ('Yes', 'No')}</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="extrinsicfailed">ExtrinsicFailed</h4>
<p>An extrinsic failed.</p>
<h5 id="attributes_10">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>dispatch_error</td>
<td><code>DispatchError</code></td>
<td><code>{'Other': None, 'CannotLookup': None, 'BadOrigin': None, 'Module': {'index': 'u8', 'error': '[u8; 4]'}, 'ConsumerRemaining': None, 'NoProviders': None, 'TooManyConsumers': None, 'Token': ('NoFunds', 'WouldDie', 'BelowMinimum', 'CannotCreate', 'UnknownAsset', 'Frozen', 'Unsupported'), 'Arithmetic': ('Underflow', 'Overflow', 'DivisionByZero'), 'Transactional': ('LimitReached', 'NoLayer')}</code></td>
</tr>
<tr>
<td>dispatch_info</td>
<td><code>DispatchInfo</code></td>
<td><code>{'weight': 'u64', 'class': ('Normal', 'Operational', 'Mandatory'), 'pays_fee': ('Yes', 'No')}</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="codeupdated">CodeUpdated</h4>
<p><code>:code</code> was updated.</p>
<h5 id="attributes_11">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="newaccount">NewAccount</h4>
<p>A new account was created.</p>
<h5 id="attributes_12">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="killedaccount">KilledAccount</h4>
<p>An account was reaped.</p>
<h5 id="attributes_13">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="remarked">Remarked</h4>
<p>On on-chain remark happened.</p>
<h5 id="attributes_14">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>sender</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>hash</td>
<td><code>T::Hash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="storage-functions">Storage functions</h3>
<hr />
<h4 id="account">Account</h4>
<p>The full account information for a particular account ID.</p>
<h5 id="python_9">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'Account', ['AccountId']
)
</code></pre>
<h5 id="return-value">Return value</h5>
<pre><code class="language-python">{
    'consumers': 'u32',
    'data': {
        'fee_frozen': 'u128',
        'free': 'u128',
        'misc_frozen': 'u128',
        'reserved': 'u128',
    },
    'nonce': 'u32',
    'providers': 'u32',
    'sufficients': 'u32',
}
</code></pre>
<hr />
<h4 id="extrinsiccount">ExtrinsicCount</h4>
<p>Total extrinsics count for the current block.</p>
<h5 id="python_10">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'ExtrinsicCount', []
)
</code></pre>
<h5 id="return-value_1">Return value</h5>
<pre><code class="language-python">'u32'
</code></pre>
<hr />
<h4 id="blockweight">BlockWeight</h4>
<p>The current weight for the block.</p>
<h5 id="python_11">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'BlockWeight', []
)
</code></pre>
<h5 id="return-value_2">Return value</h5>
<pre><code class="language-python">{'mandatory': 'u64', 'normal': 'u64', 'operational': 'u64'}
</code></pre>
<hr />
<h4 id="allextrinsicslen">AllExtrinsicsLen</h4>
<p>Total length (in bytes) for all extrinsics put together, for the current block.</p>
<h5 id="python_12">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'AllExtrinsicsLen', []
)
</code></pre>
<h5 id="return-value_3">Return value</h5>
<pre><code class="language-python">'u32'
</code></pre>
<hr />
<h4 id="blockhash">BlockHash</h4>
<p>Map of block numbers to block hashes.</p>
<h5 id="python_13">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'BlockHash', ['u32']
)
</code></pre>
<h5 id="return-value_4">Return value</h5>
<pre><code class="language-python">'[u8; 32]'
</code></pre>
<hr />
<h4 id="extrinsicdata">ExtrinsicData</h4>
<p>Extrinsics data for the current block (maps an extrinsic&#x27;s index to its data).</p>
<h5 id="python_14">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'ExtrinsicData', ['u32']
)
</code></pre>
<h5 id="return-value_5">Return value</h5>
<pre><code class="language-python">'Bytes'
</code></pre>
<hr />
<h4 id="number">Number</h4>
<p>The current block number being processed. Set by <code>execute_block</code>.</p>
<h5 id="python_15">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'Number', []
)
</code></pre>
<h5 id="return-value_6">Return value</h5>
<pre><code class="language-python">'u32'
</code></pre>
<hr />
<h4 id="parenthash">ParentHash</h4>
<p>Hash of the previous block.</p>
<h5 id="python_16">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'ParentHash', []
)
</code></pre>
<h5 id="return-value_7">Return value</h5>
<pre><code class="language-python">'[u8; 32]'
</code></pre>
<hr />
<h4 id="digest">Digest</h4>
<p>Digest of the current block, also part of the block header.</p>
<h5 id="python_17">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'Digest', []
)
</code></pre>
<h5 id="return-value_8">Return value</h5>
<pre><code class="language-python">{
    'logs': [
        {
            'Other': 'Bytes',
            None: None,
            'Consensus': ('[u8; 4]', 'Bytes'),
            'PreRuntime': ('[u8; 4]', 'Bytes'),
            'RuntimeEnvironmentUpdated': None,
            'Seal': ('[u8; 4]', 'Bytes'),
        },
    ],
}
</code></pre>
<hr />
<h4 id="events_1">Events</h4>
<p>Events deposited for the current block.</p>
<p>NOTE: The item is unbound and should therefore never be read on chain.
 It could otherwise inflate the PoV size of a block.</p>
<p>Events have a large in-memory size. Box the events to not go out-of-memory
 just in case someone still reads them from within the runtime.</p>
<h5 id="python_18">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'Events', []
)
</code></pre>
<h5 id="return-value_9">Return value</h5>
<pre><code class="language-python">[
    {
        'event': {
            'System': {
                'CodeUpdated': None,
                'ExtrinsicFailed': {
                    'dispatch_error': 'scale_info::22',
                    'dispatch_info': 'scale_info::19',
                },
                'ExtrinsicSuccess': {'dispatch_info': 'scale_info::19'},
                'KilledAccount': {'account': 'AccountId'},
                'NewAccount': {'account': 'AccountId'},
                'Remarked': {'hash': '[u8; 32]', 'sender': 'AccountId'},
            },
            None: None,
            'AllocationsOracles': (
                'MemberAdded',
                'MemberRemoved',
                'MembersSwapped',
                'MembersReset',
                'KeyChanged',
                'Dummy',
            ),
            'Balances': {
                'BalanceSet': {
                    'free': 'u128',
                    'reserved': 'u128',
                    'who': 'AccountId',
                },
                'Deposit': {'amount': 'u128', 'who': 'AccountId'},
                'DustLost': {'account': 'AccountId', 'amount': 'u128'},
                'Endowed': {'account': 'AccountId', 'free_balance': 'u128'},
                'ReserveRepatriated': {
                    'amount': 'u128',
                    'destination_status': 'scale_info::28',
                    'from': 'AccountId',
                    'to': 'AccountId',
                },
                'Reserved': {'amount': 'u128', 'who': 'AccountId'},
                'Slashed': {'amount': 'u128', 'who': 'AccountId'},
                'Transfer': {
                    'amount': 'u128',
                    'from': 'AccountId',
                    'to': 'AccountId',
                },
                'Unreserved': {'amount': 'u128', 'who': 'AccountId'},
                'Withdraw': {'amount': 'u128', 'who': 'AccountId'},
            },
            'CompanyReserve': {
                'Deposit': 'u128',
                'ReserveOp': {'Err': 'scale_info::22', 'Ok': ()},
                'SpentFunds': ('AccountId', 'u128'),
                'TipReceived': ('AccountId', 'u128'),
            },
            'CumulusXcm': {
                'ExecutedDownward': ('[u8; 8]', 'scale_info::50'),
                'InvalidFormat': '[u8; 8]',
                'UnsupportedVersion': '[u8; 8]',
            },
            'InternationalReserve': {
                'Deposit': 'u128',
                'ReserveOp': {'Err': 'scale_info::22', 'Ok': ()},
                'SpentFunds': ('AccountId', 'u128'),
                'TipReceived': ('AccountId', 'u128'),
            },
            'Mandate': {'RootOp': {'Err': 'scale_info::22', 'Ok': ()}},
            'Multisig': {
                'MultisigApproval': {
                    'approving': 'AccountId',
                    'call_hash': '[u8; 32]',
                    'multisig': 'AccountId',
                    'timepoint': 'scale_info::54',
                },
                'MultisigCancelled': {
                    'call_hash': '[u8; 32]',
                    'cancelling': 'AccountId',
                    'multisig': 'AccountId',
                    'timepoint': 'scale_info::54',
                },
                'MultisigExecuted': {
                    'approving': 'AccountId',
                    'call_hash': '[u8; 32]',
                    'multisig': 'AccountId',
                    'result': 'scale_info::33',
                    'timepoint': 'scale_info::54',
                },
                'NewMultisig': {
                    'approving': 'AccountId',
                    'call_hash': '[u8; 32]',
                    'multisig': 'AccountId',
                },
            },
            'ParachainSystem': {
                'DownwardMessagesProcessed': {
                    'dmq_head': '[u8; 32]',
                    'weight_used': 'u64',
                },
                'DownwardMessagesReceived': {'count': 'u32'},
                'UpgradeAuthorized': {'code_hash': '[u8; 32]'},
                'ValidationFunctionApplied': {'relay_chain_block_num': 'u32'},
                'ValidationFunctionDiscarded': None,
                'ValidationFunctionStored': None,
            },
            'Preimage': {
                'Cleared': {'hash': '[u8; 32]'},
                'Noted': {'hash': '[u8; 32]'},
                'Requested': {'hash': '[u8; 32]'},
            },
            'Scheduler': {
                'CallLookupFailed': {
                    'error': 'scale_info::35',
                    'id': (None, 'Bytes'),
                    'task': ('u32', 'u32'),
                },
                'Canceled': {'index': 'u32', 'when': 'u32'},
                'Dispatched': {
                    'id': (None, 'Bytes'),
                    'result': 'scale_info::33',
                    'task': ('u32', 'u32'),
                },
                'Scheduled': {'index': 'u32', 'when': 'u32'},
            },
            'Session': {'NewSession': {'session_index': 'u32'}},
            'TechnicalCommittee': {
                'Approved': {'proposal_hash': '[u8; 32]'},
                'Closed': {
                    'no': 'u32',
                    'proposal_hash': '[u8; 32]',
                    'yes': 'u32',
                },
                'Disapproved': {'proposal_hash': '[u8; 32]'},
                'Executed': {
                    'proposal_hash': '[u8; 32]',
                    'result': 'scale_info::33',
                },
                'MemberExecuted': {
                    'proposal_hash': '[u8; 32]',
                    'result': 'scale_info::33',
                },
                'Proposed': {
                    'account': 'AccountId',
                    'proposal_hash': '[u8; 32]',
                    'proposal_index': 'u32',
                    'threshold': 'u32',
                },
                'Voted': {
                    'account': 'AccountId',
                    'no': 'u32',
                    'proposal_hash': '[u8; 32]',
                    'voted': 'bool',
                    'yes': 'u32',
                },
            },
            'TechnicalMembership': (
                'MemberAdded',
                'MemberRemoved',
                'MembersSwapped',
                'MembersReset',
                'KeyChanged',
                'Dummy',
            ),
            'TransactionPayment': {
                'TransactionFeePaid': {
                    'actual_fee': 'u128',
                    'tip': 'u128',
                    'who': 'AccountId',
                },
            },
            'Uniques': {
                'ApprovalCancelled': {
                    'collection': 'u32',
                    'delegate': 'AccountId',
                    'item': 'u32',
                    'owner': 'AccountId',
                },
                'ApprovedTransfer': {
                    'collection': 'u32',
                    'delegate': 'AccountId',
                    'item': 'u32',
                    'owner': 'AccountId',
                },
                'AttributeCleared': {
                    'collection': 'u32',
                    'key': 'Bytes',
                    'maybe_item': (None, 'u32'),
                },
                'AttributeSet': {
                    'collection': 'u32',
                    'key': 'Bytes',
                    'maybe_item': (None, 'u32'),
                    'value': 'Bytes',
                },
                'Burned': {
                    'collection': 'u32',
                    'item': 'u32',
                    'owner': 'AccountId',
                },
                'CollectionFrozen': {'collection': 'u32'},
                'CollectionMaxSupplySet': {
                    'collection': 'u32',
                    'max_supply': 'u32',
                },
                'CollectionMetadataCleared': {'collection': 'u32'},
                'CollectionMetadataSet': {
                    'collection': 'u32',
                    'data': 'Bytes',
                    'is_frozen': 'bool',
                },
                'CollectionThawed': {'collection': 'u32'},
                'Created': {
                    'collection': 'u32',
                    'creator': 'AccountId',
                    'owner': 'AccountId',
                },
                'Destroyed': {'collection': 'u32'},
                'ForceCreated': {'collection': 'u32', 'owner': 'AccountId'},
                'Frozen': {'collection': 'u32', 'item': 'u32'},
                'Issued': {
                    'collection': 'u32',
                    'item': 'u32',
                    'owner': 'AccountId',
                },
                'ItemStatusChanged': {'collection': 'u32'},
                'MetadataCleared': {'collection': 'u32', 'item': 'u32'},
                'MetadataSet': {
                    'collection': 'u32',
                    'data': 'Bytes',
                    'is_frozen': 'bool',
                    'item': 'u32',
                },
                'OwnerChanged': {
                    'collection': 'u32',
                    'new_owner': 'AccountId',
                },
                'OwnershipAcceptanceChanged': {
                    'maybe_collection': (None, 'u32'),
                    'who': 'AccountId',
                },
                'Redeposited': {
                    'collection': 'u32',
                    'successful_items': ['u32'],
                },
                'TeamChanged': {
                    'admin': 'AccountId',
                    'collection': 'u32',
                    'freezer': 'AccountId',
                    'issuer': 'AccountId',
                },
                'Thawed': {'collection': 'u32', 'item': 'u32'},
                'Transferred': {
                    'collection': 'u32',
                    'from': 'AccountId',
                    'item': 'u32',
                    'to': 'AccountId',
                },
            },
            'UsaReserve': {
                'Deposit': 'u128',
                'ReserveOp': {'Err': 'scale_info::22', 'Ok': ()},
                'SpentFunds': ('AccountId', 'u128'),
                'TipReceived': ('AccountId', 'u128'),
            },
            'Utility': {
                'BatchCompleted': None,
                'BatchCompletedWithErrors': None,
                'BatchInterrupted': {
                    'error': 'scale_info::22',
                    'index': 'u32',
                },
                'DispatchedAs': {'result': 'scale_info::33'},
                'ItemCompleted': None,
                'ItemFailed': {'error': 'scale_info::22'},
            },
            'ValidatorsSet': (
                'MemberAdded',
                'MemberRemoved',
                'MembersSwapped',
                'MembersReset',
                'KeyChanged',
                'Dummy',
            ),
            'Vesting': {
                'Claimed': ('AccountId', 'u128'),
                'VestingScheduleAdded': (
                    'AccountId',
                    'AccountId',
                    'scale_info::40',
                ),
                'VestingSchedulesCanceled': 'AccountId',
            },
        },
        'phase': {
            'ApplyExtrinsic': 'u32',
            'Finalization': None,
            'Initialization': None,
        },
        'topics': ['[u8; 32]'],
    },
]
</code></pre>
<hr />
<h4 id="eventcount">EventCount</h4>
<p>The number of events in the <code>Events&amp;lt;T&amp;gt;</code> list.</p>
<h5 id="python_19">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'EventCount', []
)
</code></pre>
<h5 id="return-value_10">Return value</h5>
<pre><code class="language-python">'u32'
</code></pre>
<hr />
<h4 id="eventtopics">EventTopics</h4>
<p>Mapping between a topic (represented by T::Hash) and a vector of indexes
 of events in the <code>&amp;lt;Events&amp;lt;T&amp;gt;&amp;gt;</code> list.</p>
<p>All topic vectors have deterministic storage locations depending on the topic. This
 allows light-clients to leverage the changes trie storage tracking mechanism and
 in case of changes fetch the list of events of interest.</p>
<p>The value has the type <code>(T::BlockNumber, EventIndex)</code> because if we used only just
 the <code>EventIndex</code> then in case if the topic has the same contents on the next block
 no notification will be triggered thus the event might be lost.</p>
<h5 id="python_20">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'EventTopics', ['[u8; 32]']
)
</code></pre>
<h5 id="return-value_11">Return value</h5>
<pre><code class="language-python">[('u32', 'u32')]
</code></pre>
<hr />
<h4 id="lastruntimeupgrade">LastRuntimeUpgrade</h4>
<p>Stores the <code>spec_version</code> and <code>spec_name</code> of when the last runtime upgrade happened.</p>
<h5 id="python_21">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'LastRuntimeUpgrade', []
)
</code></pre>
<h5 id="return-value_12">Return value</h5>
<pre><code class="language-python">{'spec_name': 'Str', 'spec_version': 'u32'}
</code></pre>
<hr />
<h4 id="upgradedtou32refcount">UpgradedToU32RefCount</h4>
<p>True if we have upgraded so that <code>type RefCount</code> is <code>u32</code>. False (default) if not.</p>
<h5 id="python_22">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'UpgradedToU32RefCount', []
)
</code></pre>
<h5 id="return-value_13">Return value</h5>
<pre><code class="language-python">'bool'
</code></pre>
<hr />
<h4 id="upgradedtotriplerefcount">UpgradedToTripleRefCount</h4>
<p>True if we have upgraded so that AccountInfo contains three types of <code>RefCount</code>. False
 (default) if not.</p>
<h5 id="python_23">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'UpgradedToTripleRefCount', []
)
</code></pre>
<h5 id="return-value_14">Return value</h5>
<pre><code class="language-python">'bool'
</code></pre>
<hr />
<h4 id="executionphase">ExecutionPhase</h4>
<p>The execution phase of the block.</p>
<h5 id="python_24">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'System', 'ExecutionPhase', []
)
</code></pre>
<h5 id="return-value_15">Return value</h5>
<pre><code class="language-python">{'ApplyExtrinsic': 'u32', 'Finalization': None, 'Initialization': None}
</code></pre>
<hr />
<h3 id="constants">Constants</h3>
<hr />
<h4 id="blockweights">BlockWeights</h4>
<p>Block &amp; extrinsics weights: base values and limits.</p>
<h5 id="value">Value</h5>
<pre><code class="language-python">{
    'base_block': 5346284000,
    'max_block': 500000000000,
    'per_class': {
        'mandatory': {
            'base_extrinsic': 86298000,
            'max_extrinsic': None,
            'max_total': None,
            'reserved': None,
        },
        'normal': {
            'base_extrinsic': 86298000,
            'max_extrinsic': 324913702000,
            'max_total': 375000000000,
            'reserved': 0,
        },
        'operational': {
            'base_extrinsic': 86298000,
            'max_extrinsic': 449913702000,
            'max_total': 500000000000,
            'reserved': 125000000000,
        },
    },
}
</code></pre>
<h5 id="python_25">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('System', 'BlockWeights')
</code></pre>
<hr />
<h4 id="blocklength">BlockLength</h4>
<p>The maximum length of a block (in bytes).</p>
<h5 id="value_1">Value</h5>
<pre><code class="language-python">{'max': {'mandatory': 5242880, 'normal': 3932160, 'operational': 5242880}}
</code></pre>
<h5 id="python_26">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('System', 'BlockLength')
</code></pre>
<hr />
<h4 id="blockhashcount">BlockHashCount</h4>
<p>Maximum number of block number to block hash mappings to keep (oldest pruned first).</p>
<h5 id="value_2">Value</h5>
<pre><code class="language-python">2400
</code></pre>
<h5 id="python_27">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('System', 'BlockHashCount')
</code></pre>
<hr />
<h4 id="dbweight">DbWeight</h4>
<p>The weight of runtime database operations the runtime can invoke.</p>
<h5 id="value_3">Value</h5>
<pre><code class="language-python">{'read': 25000000, 'write': 100000000}
</code></pre>
<h5 id="python_28">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('System', 'DbWeight')
</code></pre>
<hr />
<h4 id="version">Version</h4>
<p>Get the chain&#x27;s current version.</p>
<h5 id="value_4">Value</h5>
<pre><code class="language-python">{
    'apis': [
        ('0xdd718d5cc53262d4', 1),
        ('0xab3c0572291feb8b', 1),
        ('0xdf6acb689907609b', 4),
        ('0x37e397fc7c91f5e4', 1),
        ('0x40fe3ad401f8959a', 6),
        ('0xd2bc9897eed08f15', 3),
        ('0xf78b278be53f454c', 2),
        ('0xbc9d89904f5b923f', 1),
        ('0x37c8bb1350a9a2a8', 1),
        ('0xea93e3f16f3d6962', 2),
    ],
    'authoring_version': 1,
    'impl_name': 'nodle-para',
    'impl_version': 0,
    'spec_name': 'nodle-para',
    'spec_version': 12,
    'state_version': 0,
    'transaction_version': 4,
}
</code></pre>
<h5 id="python_29">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('System', 'Version')
</code></pre>
<hr />
<h4 id="ss58prefix">SS58Prefix</h4>
<p>The designated SS85 prefix of this chain.</p>
<p>This replaces the &quot;ss58Format&quot; property declared in the chain spec. Reason is
 that the runtime should know about the prefix in order to make use of it as
 an identifier of the chain.</p>
<h5 id="value_5">Value</h5>
<pre><code class="language-python">37
</code></pre>
<h5 id="python_30">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('System', 'SS58Prefix')
</code></pre>
<hr />
<h3 id="errors">Errors</h3>
<hr />
<h4 id="invalidspecname">InvalidSpecName</h4>
<p>The name of specification does not match between the current runtime
and the new runtime.</p>
<hr />
<h4 id="specversionneedstoincrease">SpecVersionNeedsToIncrease</h4>
<p>The specification version is not allowed to decrease between the current runtime
and the new runtime.</p>
<hr />
<h4 id="failedtoextractruntimeversion">FailedToExtractRuntimeVersion</h4>
<p>Failed to extract the runtime version from the new runtime.</p>
<p>Either calling <code>Core_version</code> or decoding <code>RuntimeVersion</code> failed.</p>
<hr />
<h4 id="nondefaultcomposite">NonDefaultComposite</h4>
<p>Suicide called when the account has non-default composite data.</p>
<hr />
<h4 id="nonzerorefcount">NonZeroRefCount</h4>
<p>There is a non-zero reference count preventing the account from being purged.</p>
<hr />
<h4 id="callfiltered">CallFiltered</h4>
<p>The origin filter prevent the call to be dispatched.</p>
<hr />
<h2 id="timestamp">Timestamp</h2>
<hr />
<h3 id="calls_1">Calls</h3>
<hr />
<h4 id="set">set</h4>
<p>Set the current time.</p>
<p>This call should be invoked exactly once per block. It will panic at the finalization
phase, if this call hasn&amp;#x27;t been invoked by that time.</p>
<p>The timestamp should be greater than the previous one by the amount specified by
<code>MinimumPeriod</code>.</p>
<p>The dispatch origin for this call must be <code>Inherent</code>.</p>
<p># &lt;weight&gt;
- <code>O(1)</code> (Note that implementations of <code>OnTimestampSet</code> must also be <code>O(1)</code>)
- 1 storage read and 1 storage mutation (codec <code>O(1)</code>). (because of <code>DidUpdate::take</code> in
  <code>on_finalize</code>)
- 1 event handler <code>on_timestamp_set</code>. Must be <code>O(1)</code>.
# &lt;/weight&gt;</p>
<h5 id="attributes_15">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>now</td>
<td><code>T::Moment</code></td>
</tr>
</tbody>
</table>
<h5 id="python_31">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Timestamp', 'set', {'now': 'u64'}
)
</code></pre>
<hr />
<h3 id="storage-functions_1">Storage functions</h3>
<hr />
<h4 id="now">Now</h4>
<p>Current time for the current block.</p>
<h5 id="python_32">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Timestamp', 'Now', []
)
</code></pre>
<h5 id="return-value_16">Return value</h5>
<pre><code class="language-python">'u64'
</code></pre>
<hr />
<h4 id="didupdate">DidUpdate</h4>
<p>Did the timestamp get updated in this block?</p>
<h5 id="python_33">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Timestamp', 'DidUpdate', []
)
</code></pre>
<h5 id="return-value_17">Return value</h5>
<pre><code class="language-python">'bool'
</code></pre>
<hr />
<h3 id="constants_1">Constants</h3>
<hr />
<h4 id="minimumperiod">MinimumPeriod</h4>
<p>The minimum period between blocks. Beware that this is different to the <em>expected</em>
 period that the block production apparatus provides. Your chosen consensus system will
 generally work with this to determine a sensible block time. e.g. For Aura, it will be
 double this period on default settings.</p>
<h5 id="value_6">Value</h5>
<pre><code class="language-python">6000
</code></pre>
<h5 id="python_34">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Timestamp', 'MinimumPeriod')
</code></pre>
<hr />
<h2 id="balances">Balances</h2>
<hr />
<h3 id="calls_2">Calls</h3>
<hr />
<h4 id="transfer">transfer</h4>
<p>Transfer some liquid free balance to another account.</p>
<p><code>transfer</code> will set the <code>FreeBalance</code> of the sender and receiver.
If the sender&amp;#x27;s account is below the existential deposit as a result
of the transfer, the account will be reaped.</p>
<p>The dispatch origin for this call must be <code>Signed</code> by the transactor.</p>
<p># &lt;weight&gt;
- Dependent on arguments but not critical, given proper implementations for input config
  types. See related functions below.
- It contains a limited number of reads and writes internally and no complex
  computation.</p>
<p>Related functions:</p>
<ul>
<li><code>ensure_can_withdraw</code> is always called internally but has a bounded complexity.</li>
<li>Transferring balances to accounts that did not exist before will cause
    <code>T::OnNewAccount::on_new_account</code> to be called.</li>
<li>Removing enough funds from an account will trigger <code>T::DustRemoval::on_unbalanced</code>.</li>
<li><code>transfer_keep_alive</code> works the same way as <code>transfer</code>, but has an additional check
    that the transfer will not kill the origin account.</li>
</ul>
<hr />
<ul>
<li>Origin account is already in memory, so no DB operations for them.
# &lt;/weight&gt;</li>
</ul>
<h5 id="attributes_16">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>dest</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>value</td>
<td><code>T::Balance</code></td>
</tr>
</tbody>
</table>
<h5 id="python_35">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Balances', 'transfer', {
    'dest': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
    'value': 'u128',
}
)
</code></pre>
<hr />
<h4 id="set_balance">set_balance</h4>
<p>Set the balances of a given account.</p>
<p>This will alter <code>FreeBalance</code> and <code>ReservedBalance</code> in storage. it will
also alter the total issuance of the system (<code>TotalIssuance</code>) appropriately.
If the new free or reserved balance is below the existential deposit,
it will reset the account nonce (<code>frame_system::AccountNonce</code>).</p>
<p>The dispatch origin for this call is <code>root</code>.</p>
<h5 id="attributes_17">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>new_free</td>
<td><code>T::Balance</code></td>
</tr>
<tr>
<td>new_reserved</td>
<td><code>T::Balance</code></td>
</tr>
</tbody>
</table>
<h5 id="python_36">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Balances', 'set_balance', {
    'new_free': 'u128',
    'new_reserved': 'u128',
    'who': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
}
)
</code></pre>
<hr />
<h4 id="force_transfer">force_transfer</h4>
<p>Exactly as <code>transfer</code>, except the origin must be root and the source account may be
specified.
# &lt;weight&gt;
- Same as transfer, but additional read and write because the source account is not
  assumed to be in the overlay.
# &lt;/weight&gt;</p>
<h5 id="attributes_18">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>source</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>dest</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>value</td>
<td><code>T::Balance</code></td>
</tr>
</tbody>
</table>
<h5 id="python_37">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Balances', 'force_transfer', {
    'dest': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
    'source': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
    'value': 'u128',
}
)
</code></pre>
<hr />
<h4 id="transfer_keep_alive">transfer_keep_alive</h4>
<p>Same as the [<code>transfer</code>] call, but with a check that the transfer will not kill the
origin account.</p>
<p>99% of the time you want [<code>transfer</code>] instead.</p>
<h5 id="attributes_19">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>dest</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>value</td>
<td><code>T::Balance</code></td>
</tr>
</tbody>
</table>
<h5 id="python_38">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Balances', 'transfer_keep_alive', {
    'dest': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
    'value': 'u128',
}
)
</code></pre>
<hr />
<h4 id="transfer_all">transfer_all</h4>
<p>Transfer the entire transferable balance from the caller account.</p>
<p>NOTE: This function only attempts to transfer <em>transferable</em> balances. This means that
any locked, reserved, or existential deposits (when <code>keep_alive</code> is <code>true</code>), will not be
transferred by this function. To ensure that this function results in a killed account,
you might need to prepare the account by removing any reference counters, storage
deposits, etc...</p>
<p>The dispatch origin of this call must be Signed.</p>
<ul>
<li><code>dest</code>: The recipient of the transfer.</li>
<li><code>keep_alive</code>: A boolean to determine if the <code>transfer_all</code> operation should send all
  of the funds the account has, causing the sender account to be killed (false), or
  transfer everything except at least the existential deposit, which will guarantee to
  keep the sender account alive (true). # &lt;weight&gt;</li>
<li>O(1). Just like transfer, but reading the user&amp;#x27;s transferable balance first.
  #&lt;/weight&gt;</li>
</ul>
<h5 id="attributes_20">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>dest</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>keep_alive</td>
<td><code>bool</code></td>
</tr>
</tbody>
</table>
<h5 id="python_39">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Balances', 'transfer_all', {
    'dest': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
    'keep_alive': 'bool',
}
)
</code></pre>
<hr />
<h4 id="force_unreserve">force_unreserve</h4>
<p>Unreserve some balance from a user by force.</p>
<p>Can only be called by ROOT.</p>
<h5 id="attributes_21">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>amount</td>
<td><code>T::Balance</code></td>
</tr>
</tbody>
</table>
<h5 id="python_40">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Balances', 'force_unreserve', {
    'amount': 'u128',
    'who': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
}
)
</code></pre>
<hr />
<h3 id="events_2">Events</h3>
<hr />
<h4 id="endowed">Endowed</h4>
<p>An account was created with some free balance.</p>
<h5 id="attributes_22">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>free_balance</td>
<td><code>T::Balance</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="dustlost">DustLost</h4>
<p>An account was removed whose balance was non-zero but below ExistentialDeposit,
resulting in an outright loss.</p>
<h5 id="attributes_23">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>amount</td>
<td><code>T::Balance</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="transfer_1">Transfer</h4>
<p>Transfer succeeded.</p>
<h5 id="attributes_24">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>from</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>to</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>amount</td>
<td><code>T::Balance</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="balanceset">BalanceSet</h4>
<p>A balance was set by root.</p>
<h5 id="attributes_25">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>free</td>
<td><code>T::Balance</code></td>
<td><code>u128</code></td>
</tr>
<tr>
<td>reserved</td>
<td><code>T::Balance</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="reserved">Reserved</h4>
<p>Some balance was reserved (moved from free to reserved).</p>
<h5 id="attributes_26">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>amount</td>
<td><code>T::Balance</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="unreserved">Unreserved</h4>
<p>Some balance was unreserved (moved from reserved to free).</p>
<h5 id="attributes_27">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>amount</td>
<td><code>T::Balance</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="reserverepatriated">ReserveRepatriated</h4>
<p>Some balance was moved from the reserve of the first account to the second account.
Final argument indicates the destination balance type.</p>
<h5 id="attributes_28">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>from</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>to</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>amount</td>
<td><code>T::Balance</code></td>
<td><code>u128</code></td>
</tr>
<tr>
<td>destination_status</td>
<td><code>Status</code></td>
<td><code>('Free', 'Reserved')</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="deposit">Deposit</h4>
<p>Some amount was deposited (e.g. for transaction fees).</p>
<h5 id="attributes_29">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>amount</td>
<td><code>T::Balance</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="withdraw">Withdraw</h4>
<p>Some amount was withdrawn from the account (e.g. for transaction fees).</p>
<h5 id="attributes_30">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>amount</td>
<td><code>T::Balance</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="slashed">Slashed</h4>
<p>Some amount was removed from the account (e.g. for misbehavior).</p>
<h5 id="attributes_31">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>amount</td>
<td><code>T::Balance</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="storage-functions_2">Storage functions</h3>
<hr />
<h4 id="totalissuance">TotalIssuance</h4>
<p>The total units issued in the system.</p>
<h5 id="python_41">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Balances', 'TotalIssuance', []
)
</code></pre>
<h5 id="return-value_18">Return value</h5>
<pre><code class="language-python">'u128'
</code></pre>
<hr />
<h4 id="account_1">Account</h4>
<p>The Balances pallet example of storing the balance of an account.</p>
<p># Example</p>
<p><code>nocompile
  impl pallet_balances::Config for Runtime {
    type AccountStore = StorageMapShim&amp;lt;Self::Account&amp;lt;Runtime&amp;gt;, frame_system::Provider&amp;lt;Runtime&amp;gt;, AccountId, Self::AccountData&amp;lt;Balance&amp;gt;&amp;gt;
  }</code></p>
<p>You can also store the balance of an account in the <code>System</code> pallet.</p>
<p># Example</p>
<p><code>nocompile
  impl pallet_balances::Config for Runtime {
   type AccountStore = System
  }</code></p>
<p>But this comes with tradeoffs, storing account balances in the system pallet stores
 <code>frame_system</code> data alongside the account data contrary to storing account balances in the
 <code>Balances</code> pallet, which uses a <code>StorageMap</code> to store balances data only.
 NOTE: This is only used in the case that this pallet is used to store balances.</p>
<h5 id="python_42">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Balances', 'Account', ['AccountId']
)
</code></pre>
<h5 id="return-value_19">Return value</h5>
<pre><code class="language-python">{
    'fee_frozen': 'u128',
    'free': 'u128',
    'misc_frozen': 'u128',
    'reserved': 'u128',
}
</code></pre>
<hr />
<h4 id="locks">Locks</h4>
<p>Any liquidity locks on some account balances.
 NOTE: Should only be accessed when setting, changing and freeing a lock.</p>
<h5 id="python_43">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Balances', 'Locks', ['AccountId']
)
</code></pre>
<h5 id="return-value_20">Return value</h5>
<pre><code class="language-python">[{'amount': 'u128', 'id': '[u8; 8]', 'reasons': ('Fee', 'Misc', 'All')}]
</code></pre>
<hr />
<h4 id="reserves">Reserves</h4>
<p>Named reserves on some account balances.</p>
<h5 id="python_44">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Balances', 'Reserves', ['AccountId']
)
</code></pre>
<h5 id="return-value_21">Return value</h5>
<pre><code class="language-python">[{'amount': 'u128', 'id': '[u8; 8]'}]
</code></pre>
<hr />
<h4 id="storageversion">StorageVersion</h4>
<p>Storage version of the pallet.</p>
<p>This is set to v2.0.0 for new networks.</p>
<h5 id="python_45">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Balances', 'StorageVersion', []
)
</code></pre>
<h5 id="return-value_22">Return value</h5>
<pre><code class="language-python">('V1_0_0', 'V2_0_0')
</code></pre>
<hr />
<h3 id="constants_2">Constants</h3>
<hr />
<h4 id="existentialdeposit">ExistentialDeposit</h4>
<p>The minimum amount required to keep an account open.</p>
<h5 id="value_7">Value</h5>
<pre><code class="language-python">10000
</code></pre>
<h5 id="python_46">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Balances', 'ExistentialDeposit')
</code></pre>
<hr />
<h4 id="maxlocks">MaxLocks</h4>
<p>The maximum number of locks that should exist on an account.
 Not strictly enforced, but used for weight estimation.</p>
<h5 id="value_8">Value</h5>
<pre><code class="language-python">50
</code></pre>
<h5 id="python_47">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Balances', 'MaxLocks')
</code></pre>
<hr />
<h4 id="maxreserves">MaxReserves</h4>
<p>The maximum number of named reserves that can exist on an account.</p>
<h5 id="value_9">Value</h5>
<pre><code class="language-python">0
</code></pre>
<h5 id="python_48">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Balances', 'MaxReserves')
</code></pre>
<hr />
<h3 id="errors_1">Errors</h3>
<hr />
<h4 id="vestingbalance">VestingBalance</h4>
<p>Vesting balance too high to send value</p>
<hr />
<h4 id="liquidityrestrictions">LiquidityRestrictions</h4>
<p>Account liquidity restrictions prevent withdrawal</p>
<hr />
<h4 id="insufficientbalance">InsufficientBalance</h4>
<p>Balance too low to send value</p>
<hr />
<h4 id="existentialdeposit_1">ExistentialDeposit</h4>
<p>Value too low to create account due to existential deposit</p>
<hr />
<h4 id="keepalive">KeepAlive</h4>
<p>Transfer/payment would kill account</p>
<hr />
<h4 id="existingvestingschedule">ExistingVestingSchedule</h4>
<p>A vesting schedule already exists for this account</p>
<hr />
<h4 id="deadaccount">DeadAccount</h4>
<p>Beneficiary account must pre-exist</p>
<hr />
<h4 id="toomanyreserves">TooManyReserves</h4>
<p>Number of named reserves exceed MaxReserves</p>
<hr />
<h2 id="transactionpayment">TransactionPayment</h2>
<hr />
<h3 id="events_3">Events</h3>
<hr />
<h4 id="transactionfeepaid">TransactionFeePaid</h4>
<p>A transaction fee <code>actual_fee</code>, of which <code>tip</code> was added to the minimum inclusion fee,
has been paid by <code>who</code>.</p>
<h5 id="attributes_32">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>actual_fee</td>
<td><code>BalanceOf&lt;T&gt;</code></td>
<td><code>u128</code></td>
</tr>
<tr>
<td>tip</td>
<td><code>BalanceOf&lt;T&gt;</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="storage-functions_3">Storage functions</h3>
<hr />
<h4 id="nextfeemultiplier">NextFeeMultiplier</h4>
<h5 id="python_49">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'TransactionPayment', 'NextFeeMultiplier', []
)
</code></pre>
<h5 id="return-value_23">Return value</h5>
<pre><code class="language-python">'u128'
</code></pre>
<hr />
<h4 id="storageversion_1">StorageVersion</h4>
<h5 id="python_50">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'TransactionPayment', 'StorageVersion', []
)
</code></pre>
<h5 id="return-value_24">Return value</h5>
<pre><code class="language-python">('V1Ancient', 'V2')
</code></pre>
<hr />
<h3 id="constants_3">Constants</h3>
<hr />
<h4 id="operationalfeemultiplier">OperationalFeeMultiplier</h4>
<p>A fee mulitplier for <code>Operational</code> extrinsics to compute &quot;virtual tip&quot; to boost their
 <code>priority</code></p>
<p>This value is multipled by the <code>final_fee</code> to obtain a &quot;virtual tip&quot; that is later
 added to a tip component in regular <code>priority</code> calculations.
 It means that a <code>Normal</code> transaction can front-run a similarly-sized <code>Operational</code>
 extrinsic (with no tip), by including a tip value greater than the virtual tip.</p>
<p><code>``rust,ignore
 // For</code>Normal`
 let priority = priority_calc(tip);</p>
<p>// For <code>Operational</code>
 let virtual_tip = (inclusion_fee + tip) * OperationalFeeMultiplier;
 let priority = priority_calc(tip + virtual_tip);
 ```</p>
<p>Note that since we use <code>final_fee</code> the multiplier applies also to the regular <code>tip</code>
 sent with the transaction. So, not only does the transaction get a priority bump based
 on the <code>inclusion_fee</code>, but we also amplify the impact of tips applied to <code>Operational</code>
 transactions.</p>
<h5 id="value_10">Value</h5>
<pre><code class="language-python">5
</code></pre>
<h5 id="python_51">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('TransactionPayment', 'OperationalFeeMultiplier')
</code></pre>
<hr />
<h2 id="randomnesscollectiveflip">RandomnessCollectiveFlip</h2>
<hr />
<h3 id="storage-functions_4">Storage functions</h3>
<hr />
<h4 id="randommaterial">RandomMaterial</h4>
<p>Series of block headers from the last 81 blocks that acts as random seed material. This
 is arranged as a ring buffer with <code>block_number % 81</code> being the index into the <code>Vec</code> of
 the oldest hash.</p>
<h5 id="python_52">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'RandomnessCollectiveFlip', 'RandomMaterial', []
)
</code></pre>
<h5 id="return-value_25">Return value</h5>
<pre><code class="language-python">['[u8; 32]']
</code></pre>
<hr />
<h2 id="scheduler">Scheduler</h2>
<hr />
<h3 id="calls_3">Calls</h3>
<hr />
<h4 id="schedule">schedule</h4>
<p>Anonymously schedule a task.</p>
<h5 id="attributes_33">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>when</td>
<td><code>T::BlockNumber</code></td>
</tr>
<tr>
<td>maybe_periodic</td>
<td><code>Option&lt;schedule::Period&lt;T::BlockNumber&gt;&gt;</code></td>
</tr>
<tr>
<td>priority</td>
<td><code>schedule::Priority</code></td>
</tr>
<tr>
<td>call</td>
<td><code>Box&lt;CallOrHashOf&lt;T&gt;&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_53">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Scheduler', 'schedule', {
    'call': {
        'Hash': '[u8; 32]',
        'Value': 'Call',
    },
    'maybe_periodic': (
        None,
        ('u32', 'u32'),
    ),
    'priority': 'u8',
    'when': 'u32',
}
)
</code></pre>
<hr />
<h4 id="cancel">cancel</h4>
<p>Cancel an anonymously scheduled task.</p>
<h5 id="attributes_34">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>when</td>
<td><code>T::BlockNumber</code></td>
</tr>
<tr>
<td>index</td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<h5 id="python_54">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Scheduler', 'cancel', {'index': 'u32', 'when': 'u32'}
)
</code></pre>
<hr />
<h4 id="schedule_named">schedule_named</h4>
<p>Schedule a named task.</p>
<h5 id="attributes_35">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td><code>Vec&lt;u8&gt;</code></td>
</tr>
<tr>
<td>when</td>
<td><code>T::BlockNumber</code></td>
</tr>
<tr>
<td>maybe_periodic</td>
<td><code>Option&lt;schedule::Period&lt;T::BlockNumber&gt;&gt;</code></td>
</tr>
<tr>
<td>priority</td>
<td><code>schedule::Priority</code></td>
</tr>
<tr>
<td>call</td>
<td><code>Box&lt;CallOrHashOf&lt;T&gt;&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_55">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Scheduler', 'schedule_named', {
    'call': {
        'Hash': '[u8; 32]',
        'Value': 'Call',
    },
    'id': 'Bytes',
    'maybe_periodic': (
        None,
        ('u32', 'u32'),
    ),
    'priority': 'u8',
    'when': 'u32',
}
)
</code></pre>
<hr />
<h4 id="cancel_named">cancel_named</h4>
<p>Cancel a named scheduled task.</p>
<h5 id="attributes_36">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td><code>Vec&lt;u8&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_56">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Scheduler', 'cancel_named', {'id': 'Bytes'}
)
</code></pre>
<hr />
<h4 id="schedule_after">schedule_after</h4>
<p>Anonymously schedule a task after a delay.</p>
<p># &lt;weight&gt;
Same as [<code>schedule</code>].
# &lt;/weight&gt;</p>
<h5 id="attributes_37">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>after</td>
<td><code>T::BlockNumber</code></td>
</tr>
<tr>
<td>maybe_periodic</td>
<td><code>Option&lt;schedule::Period&lt;T::BlockNumber&gt;&gt;</code></td>
</tr>
<tr>
<td>priority</td>
<td><code>schedule::Priority</code></td>
</tr>
<tr>
<td>call</td>
<td><code>Box&lt;CallOrHashOf&lt;T&gt;&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_57">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Scheduler', 'schedule_after', {
    'after': 'u32',
    'call': {
        'Hash': '[u8; 32]',
        'Value': 'Call',
    },
    'maybe_periodic': (
        None,
        ('u32', 'u32'),
    ),
    'priority': 'u8',
}
)
</code></pre>
<hr />
<h4 id="schedule_named_after">schedule_named_after</h4>
<p>Schedule a named task after a delay.</p>
<p># &lt;weight&gt;
Same as <a href="Self::schedule_named"><code>schedule_named</code></a>.
# &lt;/weight&gt;</p>
<h5 id="attributes_38">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td><code>Vec&lt;u8&gt;</code></td>
</tr>
<tr>
<td>after</td>
<td><code>T::BlockNumber</code></td>
</tr>
<tr>
<td>maybe_periodic</td>
<td><code>Option&lt;schedule::Period&lt;T::BlockNumber&gt;&gt;</code></td>
</tr>
<tr>
<td>priority</td>
<td><code>schedule::Priority</code></td>
</tr>
<tr>
<td>call</td>
<td><code>Box&lt;CallOrHashOf&lt;T&gt;&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_58">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Scheduler', 'schedule_named_after', {
    'after': 'u32',
    'call': {
        'Hash': '[u8; 32]',
        'Value': 'Call',
    },
    'id': 'Bytes',
    'maybe_periodic': (
        None,
        ('u32', 'u32'),
    ),
    'priority': 'u8',
}
)
</code></pre>
<hr />
<h3 id="events_4">Events</h3>
<hr />
<h4 id="scheduled">Scheduled</h4>
<p>Scheduled some task.</p>
<h5 id="attributes_39">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>when</td>
<td><code>T::BlockNumber</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>index</td>
<td><code>u32</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="canceled">Canceled</h4>
<p>Canceled some task.</p>
<h5 id="attributes_40">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>when</td>
<td><code>T::BlockNumber</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>index</td>
<td><code>u32</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="dispatched">Dispatched</h4>
<p>Dispatched some task.</p>
<h5 id="attributes_41">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>task</td>
<td><code>TaskAddress&lt;T::BlockNumber&gt;</code></td>
<td><code>('u32', 'u32')</code></td>
</tr>
<tr>
<td>id</td>
<td><code>Option&lt;Vec&lt;u8&gt;&gt;</code></td>
<td><code>(None, 'Bytes')</code></td>
</tr>
<tr>
<td>result</td>
<td><code>DispatchResult</code></td>
<td><code>{'Ok': (), 'Err': {'Other': None, 'CannotLookup': None, 'BadOrigin': None, 'Module': {'index': 'u8', 'error': '[u8; 4]'}, 'ConsumerRemaining': None, 'NoProviders': None, 'TooManyConsumers': None, 'Token': ('NoFunds', 'WouldDie', 'BelowMinimum', 'CannotCreate', 'UnknownAsset', 'Frozen', 'Unsupported'), 'Arithmetic': ('Underflow', 'Overflow', 'DivisionByZero'), 'Transactional': ('LimitReached', 'NoLayer')}}</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="calllookupfailed">CallLookupFailed</h4>
<p>The call for the provided hash was not found so the task has been aborted.</p>
<h5 id="attributes_42">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>task</td>
<td><code>TaskAddress&lt;T::BlockNumber&gt;</code></td>
<td><code>('u32', 'u32')</code></td>
</tr>
<tr>
<td>id</td>
<td><code>Option&lt;Vec&lt;u8&gt;&gt;</code></td>
<td><code>(None, 'Bytes')</code></td>
</tr>
<tr>
<td>error</td>
<td><code>LookupError</code></td>
<td><code>('Unknown', 'BadFormat')</code></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="storage-functions_5">Storage functions</h3>
<hr />
<h4 id="agenda">Agenda</h4>
<p>Items to be executed, indexed by the block number that they should be executed on.</p>
<h5 id="python_59">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Scheduler', 'Agenda', ['u32']
)
</code></pre>
<h5 id="return-value_26">Return value</h5>
<pre><code class="language-python">[
    (
        None,
        {
            'call': {'Hash': '[u8; 32]', 'Value': 'Call'},
            'maybe_id': (None, 'Bytes'),
            'maybe_periodic': (None, ('u32', 'u32')),
            'origin': {
                'CumulusXcm': {'Relay': None, 'SiblingParachain': 'u32'},
                'TechnicalCommittee': {
                    'Member': 'AccountId',
                    'Members': ('u32', 'u32'),
                    '_Phantom': None,
                },
                'Void': (),
                'system': {'None': None, 'Root': None, 'Signed': 'AccountId'},
                None: None,
            },
            'priority': 'u8',
        },
    ),
]
</code></pre>
<hr />
<h4 id="lookup">Lookup</h4>
<p>Lookup from identity to the block number and index of the task.</p>
<h5 id="python_60">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Scheduler', 'Lookup', ['Bytes']
)
</code></pre>
<h5 id="return-value_27">Return value</h5>
<pre><code class="language-python">('u32', 'u32')
</code></pre>
<hr />
<h3 id="constants_4">Constants</h3>
<hr />
<h4 id="maximumweight">MaximumWeight</h4>
<p>The maximum weight that may be scheduled per block for any dispatchables of less
 priority than <code>schedule::HARD_DEADLINE</code>.</p>
<h5 id="value_11">Value</h5>
<pre><code class="language-python">400000000000
</code></pre>
<h5 id="python_61">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Scheduler', 'MaximumWeight')
</code></pre>
<hr />
<h4 id="maxscheduledperblock">MaxScheduledPerBlock</h4>
<p>The maximum number of scheduled calls in the queue for a single block.
 Not strictly enforced, but used for weight estimation.</p>
<h5 id="value_12">Value</h5>
<pre><code class="language-python">50
</code></pre>
<h5 id="python_62">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Scheduler', 'MaxScheduledPerBlock')
</code></pre>
<hr />
<h3 id="errors_2">Errors</h3>
<hr />
<h4 id="failedtoschedule">FailedToSchedule</h4>
<p>Failed to schedule a call</p>
<hr />
<h4 id="notfound">NotFound</h4>
<p>Cannot find the scheduled call.</p>
<hr />
<h4 id="targetblocknumberinpast">TargetBlockNumberInPast</h4>
<p>Given target block number is in the past.</p>
<hr />
<h4 id="reschedulenochange">RescheduleNoChange</h4>
<p>Reschedule failed because it does not change scheduled time.</p>
<hr />
<h2 id="companyreserve">CompanyReserve</h2>
<hr />
<h3 id="calls_4">Calls</h3>
<hr />
<h4 id="spend">spend</h4>
<p>Spend <code>amount</code> funds from the reserve account to <code>to</code>.</p>
<h5 id="attributes_43">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>to</td>
<td><code>T::AccountId</code></td>
</tr>
<tr>
<td>amount</td>
<td><code>BalanceOf&lt;T, I&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_63">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'CompanyReserve', 'spend', {'amount': 'u128', 'to': 'AccountId'}
)
</code></pre>
<hr />
<h4 id="tip">tip</h4>
<p>Deposit <code>amount</code> tokens in the treasure account</p>
<h5 id="attributes_44">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td><code>BalanceOf&lt;T, I&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_64">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'CompanyReserve', 'tip', {'amount': 'u128'}
)
</code></pre>
<hr />
<h4 id="apply_as">apply_as</h4>
<p>Dispatch a call as coming from the reserve account</p>
<h5 id="attributes_45">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>call</td>
<td><code>Box&lt;&lt;T as Config&lt;I&gt;&gt;::Call&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_65">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'CompanyReserve', 'apply_as', {'call': 'Call'}
)
</code></pre>
<hr />
<h3 id="events_5">Events</h3>
<hr />
<h4 id="deposit_1">Deposit</h4>
<p>Some amount was deposited (e.g. for transaction fees).</p>
<h5 id="attributes_46">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>BalanceOf&lt;T, I&gt;</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="spentfunds">SpentFunds</h4>
<p>Some funds were spent from the reserve.</p>
<h5 id="attributes_47">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>None</td>
<td><code>BalanceOf&lt;T, I&gt;</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="tipreceived">TipReceived</h4>
<p>Someone tipped the company reserve</p>
<h5 id="attributes_48">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>None</td>
<td><code>BalanceOf&lt;T, I&gt;</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="reserveop">ReserveOp</h4>
<p>We executed a call coming from the company reserve account</p>
<h5 id="attributes_49">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>DispatchResult</code></td>
<td><code>{'Ok': (), 'Err': {'Other': None, 'CannotLookup': None, 'BadOrigin': None, 'Module': {'index': 'u8', 'error': '[u8; 4]'}, 'ConsumerRemaining': None, 'NoProviders': None, 'TooManyConsumers': None, 'Token': ('NoFunds', 'WouldDie', 'BelowMinimum', 'CannotCreate', 'UnknownAsset', 'Frozen', 'Unsupported'), 'Arithmetic': ('Underflow', 'Overflow', 'DivisionByZero'), 'Transactional': ('LimitReached', 'NoLayer')}}</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="internationalreserve">InternationalReserve</h2>
<hr />
<h3 id="calls_5">Calls</h3>
<hr />
<h4 id="spend_1">spend</h4>
<p>Spend <code>amount</code> funds from the reserve account to <code>to</code>.</p>
<h5 id="attributes_50">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>to</td>
<td><code>T::AccountId</code></td>
</tr>
<tr>
<td>amount</td>
<td><code>BalanceOf&lt;T, I&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_66">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'InternationalReserve', 'spend', {'amount': 'u128', 'to': 'AccountId'}
)
</code></pre>
<hr />
<h4 id="tip_1">tip</h4>
<p>Deposit <code>amount</code> tokens in the treasure account</p>
<h5 id="attributes_51">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td><code>BalanceOf&lt;T, I&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_67">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'InternationalReserve', 'tip', {'amount': 'u128'}
)
</code></pre>
<hr />
<h4 id="apply_as_1">apply_as</h4>
<p>Dispatch a call as coming from the reserve account</p>
<h5 id="attributes_52">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>call</td>
<td><code>Box&lt;&lt;T as Config&lt;I&gt;&gt;::Call&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_68">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'InternationalReserve', 'apply_as', {'call': 'Call'}
)
</code></pre>
<hr />
<h3 id="events_6">Events</h3>
<hr />
<h4 id="deposit_2">Deposit</h4>
<p>Some amount was deposited (e.g. for transaction fees).</p>
<h5 id="attributes_53">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>BalanceOf&lt;T, I&gt;</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="spentfunds_1">SpentFunds</h4>
<p>Some funds were spent from the reserve.</p>
<h5 id="attributes_54">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>None</td>
<td><code>BalanceOf&lt;T, I&gt;</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="tipreceived_1">TipReceived</h4>
<p>Someone tipped the company reserve</p>
<h5 id="attributes_55">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>None</td>
<td><code>BalanceOf&lt;T, I&gt;</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="reserveop_1">ReserveOp</h4>
<p>We executed a call coming from the company reserve account</p>
<h5 id="attributes_56">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>DispatchResult</code></td>
<td><code>{'Ok': (), 'Err': {'Other': None, 'CannotLookup': None, 'BadOrigin': None, 'Module': {'index': 'u8', 'error': '[u8; 4]'}, 'ConsumerRemaining': None, 'NoProviders': None, 'TooManyConsumers': None, 'Token': ('NoFunds', 'WouldDie', 'BelowMinimum', 'CannotCreate', 'UnknownAsset', 'Frozen', 'Unsupported'), 'Arithmetic': ('Underflow', 'Overflow', 'DivisionByZero'), 'Transactional': ('LimitReached', 'NoLayer')}}</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="usareserve">UsaReserve</h2>
<hr />
<h3 id="calls_6">Calls</h3>
<hr />
<h4 id="spend_2">spend</h4>
<p>Spend <code>amount</code> funds from the reserve account to <code>to</code>.</p>
<h5 id="attributes_57">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>to</td>
<td><code>T::AccountId</code></td>
</tr>
<tr>
<td>amount</td>
<td><code>BalanceOf&lt;T, I&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_69">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'UsaReserve', 'spend', {'amount': 'u128', 'to': 'AccountId'}
)
</code></pre>
<hr />
<h4 id="tip_2">tip</h4>
<p>Deposit <code>amount</code> tokens in the treasure account</p>
<h5 id="attributes_58">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td><code>BalanceOf&lt;T, I&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_70">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'UsaReserve', 'tip', {'amount': 'u128'}
)
</code></pre>
<hr />
<h4 id="apply_as_2">apply_as</h4>
<p>Dispatch a call as coming from the reserve account</p>
<h5 id="attributes_59">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>call</td>
<td><code>Box&lt;&lt;T as Config&lt;I&gt;&gt;::Call&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_71">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'UsaReserve', 'apply_as', {'call': 'Call'}
)
</code></pre>
<hr />
<h3 id="events_7">Events</h3>
<hr />
<h4 id="deposit_3">Deposit</h4>
<p>Some amount was deposited (e.g. for transaction fees).</p>
<h5 id="attributes_60">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>BalanceOf&lt;T, I&gt;</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="spentfunds_2">SpentFunds</h4>
<p>Some funds were spent from the reserve.</p>
<h5 id="attributes_61">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>None</td>
<td><code>BalanceOf&lt;T, I&gt;</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="tipreceived_2">TipReceived</h4>
<p>Someone tipped the company reserve</p>
<h5 id="attributes_62">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>None</td>
<td><code>BalanceOf&lt;T, I&gt;</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="reserveop_2">ReserveOp</h4>
<p>We executed a call coming from the company reserve account</p>
<h5 id="attributes_63">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>DispatchResult</code></td>
<td><code>{'Ok': (), 'Err': {'Other': None, 'CannotLookup': None, 'BadOrigin': None, 'Module': {'index': 'u8', 'error': '[u8; 4]'}, 'ConsumerRemaining': None, 'NoProviders': None, 'TooManyConsumers': None, 'Token': ('NoFunds', 'WouldDie', 'BelowMinimum', 'CannotCreate', 'UnknownAsset', 'Frozen', 'Unsupported'), 'Arithmetic': ('Underflow', 'Overflow', 'DivisionByZero'), 'Transactional': ('LimitReached', 'NoLayer')}}</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="vesting">Vesting</h2>
<hr />
<h3 id="calls_7">Calls</h3>
<hr />
<h4 id="claim">claim</h4>
<p>Claim funds that have been vested so far</p>
<h5 id="attributes_64">Attributes</h5>
<p>No attributes</p>
<h5 id="python_72">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Vesting', 'claim', {}
)
</code></pre>
<hr />
<h4 id="add_vesting_schedule">add_vesting_schedule</h4>
<p>Wire funds to be vested by the receiver</p>
<h5 id="attributes_65">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>dest</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>schedule</td>
<td><code>VestingScheduleOf&lt;T&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_73">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Vesting', 'add_vesting_schedule', {
    'dest': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
    'schedule': {
        'per_period': 'u128',
        'period': 'u32',
        'period_count': 'u32',
        'start': 'u32',
    },
}
)
</code></pre>
<hr />
<h4 id="cancel_all_vesting_schedules">cancel_all_vesting_schedules</h4>
<p>Cancel all vested schedules for the given user. If there are coins to be
claimed they will be auto claimed for the given user. If <code>limit_to_free_balance</code>
is set to true we will not error if the free balance of <code>who</code> has less coins
than what was granted and is being revoked (useful if the state was corrupted).</p>
<h5 id="attributes_66">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>funds_collector</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
</tbody>
</table>
<h5 id="python_74">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Vesting', 'cancel_all_vesting_schedules', {
    'funds_collector': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
    'who': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
}
)
</code></pre>
<hr />
<h3 id="events_8">Events</h3>
<hr />
<h4 id="vestingscheduleadded">VestingScheduleAdded</h4>
<p>Added new vesting schedule [from, to, vesting_schedule]</p>
<h5 id="attributes_67">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>None</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>None</td>
<td><code>VestingScheduleOf&lt;T&gt;</code></td>
<td><code>{'start': 'u32', 'period': 'u32', 'period_count': 'u32', 'per_period': 'u128'}</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="claimed">Claimed</h4>
<p>Claimed vesting [who, locked_amount]</p>
<h5 id="attributes_68">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>None</td>
<td><code>BalanceOf&lt;T&gt;</code></td>
<td><code>u128</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="vestingschedulescanceled">VestingSchedulesCanceled</h4>
<p>Canceled all vesting schedules [who]</p>
<h5 id="attributes_69">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="storage-functions_6">Storage functions</h3>
<hr />
<h4 id="vestingschedules">VestingSchedules</h4>
<h5 id="python_75">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Vesting', 'VestingSchedules', ['AccountId']
)
</code></pre>
<h5 id="return-value_28">Return value</h5>
<pre><code class="language-python">[
    {
        'per_period': 'u128',
        'period': 'u32',
        'period_count': 'u32',
        'start': 'u32',
    },
]
</code></pre>
<hr />
<h4 id="counterforvestingschedules">CounterForVestingSchedules</h4>
<p>Counter for the related counted storage map</p>
<h5 id="python_76">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Vesting', 'CounterForVestingSchedules', []
)
</code></pre>
<h5 id="return-value_29">Return value</h5>
<pre><code class="language-python">'u32'
</code></pre>
<hr />
<h4 id="storageversion_2">StorageVersion</h4>
<h5 id="python_77">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Vesting', 'StorageVersion', []
)
</code></pre>
<h5 id="return-value_30">Return value</h5>
<pre><code class="language-python">('V0', 'V1')
</code></pre>
<hr />
<h3 id="constants_5">Constants</h3>
<hr />
<h4 id="maxschedule">MaxSchedule</h4>
<p>The maximum number of vesting schedule.</p>
<h5 id="value_13">Value</h5>
<pre><code class="language-python">100
</code></pre>
<h5 id="python_78">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Vesting', 'MaxSchedule')
</code></pre>
<hr />
<h3 id="errors_3">Errors</h3>
<hr />
<h4 id="zerovestingperiod">ZeroVestingPeriod</h4>
<hr />
<h4 id="zerovestingperiodcount">ZeroVestingPeriodCount</h4>
<hr />
<h4 id="numoverflow">NumOverflow</h4>
<hr />
<h4 id="insufficientbalancetolock">InsufficientBalanceToLock</h4>
<hr />
<h4 id="emptyschedules">EmptySchedules</h4>
<hr />
<h4 id="vestingtoself">VestingToSelf</h4>
<hr />
<h4 id="maxscheduleoverflow">MaxScheduleOverflow</h4>
<hr />
<h2 id="mandate">Mandate</h2>
<hr />
<h3 id="calls_8">Calls</h3>
<hr />
<h4 id="apply">apply</h4>
<p>Let the configured origin dispatch a call as root</p>
<h5 id="attributes_70">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>call</td>
<td><code>Box&lt;&lt;T as Config&gt;::Call&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_79">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Mandate', 'apply', {'call': 'Call'}
)
</code></pre>
<hr />
<h3 id="events_9">Events</h3>
<hr />
<h4 id="rootop">RootOp</h4>
<p>A root operation was executed, show result</p>
<h5 id="attributes_71">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>DispatchResult</code></td>
<td><code>{'Ok': (), 'Err': {'Other': None, 'CannotLookup': None, 'BadOrigin': None, 'Module': {'index': 'u8', 'error': '[u8; 4]'}, 'ConsumerRemaining': None, 'NoProviders': None, 'TooManyConsumers': None, 'Token': ('NoFunds', 'WouldDie', 'BelowMinimum', 'CannotCreate', 'UnknownAsset', 'Frozen', 'Unsupported'), 'Arithmetic': ('Underflow', 'Overflow', 'DivisionByZero'), 'Transactional': ('LimitReached', 'NoLayer')}}</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="technicalcommittee">TechnicalCommittee</h2>
<hr />
<h3 id="calls_9">Calls</h3>
<hr />
<h4 id="set_members">set_members</h4>
<p>Set the collective&amp;#x27;s membership.</p>
<ul>
<li><code>new_members</code>: The new member list. Be nice to the chain and provide it sorted.</li>
<li><code>prime</code>: The prime member whose vote sets the default.</li>
<li><code>old_count</code>: The upper bound for the previous number of members in storage. Used for
  weight estimation.</li>
</ul>
<p>Requires root origin.</p>
<p>NOTE: Does not enforce the expected <code>MaxMembers</code> limit on the amount of members, but
      the weight estimations rely on it to estimate dispatchable weight.</p>
<p># WARNING:</p>
<p>The <code>pallet-collective</code> can also be managed by logic outside of the pallet through the
implementation of the trait [<code>ChangeMembers</code>].
Any call to <code>set_members</code> must be careful that the member set doesn&amp;#x27;t get out of sync
with other logic managing the member set.</p>
<p># &lt;weight&gt;
## Weight
- <code>O(MP + N)</code> where:
  - <code>M</code> old-members-count (code- and governance-bounded)
  - <code>N</code> new-members-count (code- and governance-bounded)
  - <code>P</code> proposals-count (code-bounded)
- DB:
  - 1 storage mutation (codec <code>O(M)</code> read, <code>O(N)</code> write) for reading and writing the
    members
  - 1 storage read (codec <code>O(P)</code>) for reading the proposals
  - <code>P</code> storage mutations (codec <code>O(M)</code>) for updating the votes for each proposal
  - 1 storage write (codec <code>O(1)</code>) for deleting the old <code>prime</code> and setting the new one
# &lt;/weight&gt;</p>
<h5 id="attributes_72">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>new_members</td>
<td><code>Vec&lt;T::AccountId&gt;</code></td>
</tr>
<tr>
<td>prime</td>
<td><code>Option&lt;T::AccountId&gt;</code></td>
</tr>
<tr>
<td>old_count</td>
<td><code>MemberCount</code></td>
</tr>
</tbody>
</table>
<h5 id="python_80">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'TechnicalCommittee', 'set_members', {
    'new_members': ['AccountId'],
    'old_count': 'u32',
    'prime': (None, 'AccountId'),
}
)
</code></pre>
<hr />
<h4 id="execute">execute</h4>
<p>Dispatch a proposal from a member using the <code>Member</code> origin.</p>
<p>Origin must be a member of the collective.</p>
<p># &lt;weight&gt;
## Weight
- <code>O(M + P)</code> where <code>M</code> members-count (code-bounded) and <code>P</code> complexity of dispatching
  <code>proposal</code>
- DB: 1 read (codec <code>O(M)</code>) + DB access of <code>proposal</code>
- 1 event
# &lt;/weight&gt;</p>
<h5 id="attributes_73">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposal</td>
<td><code>Box&lt;&lt;T as Config&lt;I&gt;&gt;::Proposal&gt;</code></td>
</tr>
<tr>
<td>length_bound</td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<h5 id="python_81">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'TechnicalCommittee', 'execute', {
    'length_bound': 'u32',
    'proposal': 'Call',
}
)
</code></pre>
<hr />
<h4 id="propose">propose</h4>
<p>Add a new proposal to either be voted on or executed directly.</p>
<p>Requires the sender to be member.</p>
<p><code>threshold</code> determines whether <code>proposal</code> is executed directly (<code>threshold &amp;lt; 2</code>)
or put up for voting.</p>
<p># &lt;weight&gt;
## Weight
- <code>O(B + M + P1)</code> or <code>O(B + M + P2)</code> where:
  - <code>B</code> is <code>proposal</code> size in bytes (length-fee-bounded)
  - <code>M</code> is members-count (code- and governance-bounded)
  - branching is influenced by <code>threshold</code> where:
    - <code>P1</code> is proposal execution complexity (<code>threshold &amp;lt; 2</code>)
    - <code>P2</code> is proposals-count (code-bounded) (<code>threshold &amp;gt;= 2</code>)
- DB:
  - 1 storage read <code>is_member</code> (codec <code>O(M)</code>)
  - 1 storage read <code>ProposalOf::contains_key</code> (codec <code>O(1)</code>)
  - DB accesses influenced by <code>threshold</code>:
    - EITHER storage accesses done by <code>proposal</code> (<code>threshold &amp;lt; 2</code>)
    - OR proposal insertion (<code>threshold &amp;lt;= 2</code>)
      - 1 storage mutation <code>Proposals</code> (codec <code>O(P2)</code>)
      - 1 storage mutation <code>ProposalCount</code> (codec <code>O(1)</code>)
      - 1 storage write <code>ProposalOf</code> (codec <code>O(B)</code>)
      - 1 storage write <code>Voting</code> (codec <code>O(M)</code>)
  - 1 event
# &lt;/weight&gt;</p>
<h5 id="attributes_74">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>threshold</td>
<td><code>MemberCount</code></td>
</tr>
<tr>
<td>proposal</td>
<td><code>Box&lt;&lt;T as Config&lt;I&gt;&gt;::Proposal&gt;</code></td>
</tr>
<tr>
<td>length_bound</td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<h5 id="python_82">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'TechnicalCommittee', 'propose', {
    'length_bound': 'u32',
    'proposal': 'Call',
    'threshold': 'u32',
}
)
</code></pre>
<hr />
<h4 id="vote">vote</h4>
<p>Add an aye or nay vote for the sender to the given proposal.</p>
<p>Requires the sender to be a member.</p>
<p>Transaction fees will be waived if the member is voting on any particular proposal
for the first time and the call is successful. Subsequent vote changes will charge a
fee.
# &lt;weight&gt;
## Weight
- <code>O(M)</code> where <code>M</code> is members-count (code- and governance-bounded)
- DB:
  - 1 storage read <code>Members</code> (codec <code>O(M)</code>)
  - 1 storage mutation <code>Voting</code> (codec <code>O(M)</code>)
- 1 event
# &lt;/weight&gt;</p>
<h5 id="attributes_75">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposal</td>
<td><code>T::Hash</code></td>
</tr>
<tr>
<td>index</td>
<td><code>ProposalIndex</code></td>
</tr>
<tr>
<td>approve</td>
<td><code>bool</code></td>
</tr>
</tbody>
</table>
<h5 id="python_83">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'TechnicalCommittee', 'vote', {
    'approve': 'bool',
    'index': 'u32',
    'proposal': '[u8; 32]',
}
)
</code></pre>
<hr />
<h4 id="close">close</h4>
<p>Close a vote that is either approved, disapproved or whose voting period has ended.</p>
<p>May be called by any signed account in order to finish voting and close the proposal.</p>
<p>If called before the end of the voting period it will only close the vote if it is
has enough votes to be approved or disapproved.</p>
<p>If called after the end of the voting period abstentions are counted as rejections
unless there is a prime member set and the prime member cast an approval.</p>
<p>If the close operation completes successfully with disapproval, the transaction fee will
be waived. Otherwise execution of the approved operation will be charged to the caller.</p>
<ul>
<li><code>proposal_weight_bound</code>: The maximum amount of weight consumed by executing the closed
proposal.</li>
<li><code>length_bound</code>: The upper bound for the length of the proposal in storage. Checked via
<code>storage::read</code> so it is <code>size_of::&amp;lt;u32&amp;gt;() == 4</code> larger than the pure length.</li>
</ul>
<p># &lt;weight&gt;
## Weight
- <code>O(B + M + P1 + P2)</code> where:
  - <code>B</code> is <code>proposal</code> size in bytes (length-fee-bounded)
  - <code>M</code> is members-count (code- and governance-bounded)
  - <code>P1</code> is the complexity of <code>proposal</code> preimage.
  - <code>P2</code> is proposal-count (code-bounded)
- DB:
 - 2 storage reads (<code>Members</code>: codec <code>O(M)</code>, <code>Prime</code>: codec <code>O(1)</code>)
 - 3 mutations (<code>Voting</code>: codec <code>O(M)</code>, <code>ProposalOf</code>: codec <code>O(B)</code>, <code>Proposals</code>: codec
   <code>O(P2)</code>)
 - any mutations done while executing <code>proposal</code> (<code>P1</code>)
- up to 3 events
# &lt;/weight&gt;</p>
<h5 id="attributes_76">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposal_hash</td>
<td><code>T::Hash</code></td>
</tr>
<tr>
<td>index</td>
<td><code>ProposalIndex</code></td>
</tr>
<tr>
<td>proposal_weight_bound</td>
<td><code>Weight</code></td>
</tr>
<tr>
<td>length_bound</td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<h5 id="python_84">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'TechnicalCommittee', 'close', {
    'index': 'u32',
    'length_bound': 'u32',
    'proposal_hash': '[u8; 32]',
    'proposal_weight_bound': 'u64',
}
)
</code></pre>
<hr />
<h4 id="disapprove_proposal">disapprove_proposal</h4>
<p>Disapprove a proposal, close, and remove it from the system, regardless of its current
state.</p>
<p>Must be called by the Root origin.</p>
<p>Parameters:
* <code>proposal_hash</code>: The hash of the proposal that should be disapproved.</p>
<p># &lt;weight&gt;
Complexity: O(P) where P is the number of max proposals
DB Weight:
* Reads: Proposals
* Writes: Voting, Proposals, ProposalOf
# &lt;/weight&gt;</p>
<h5 id="attributes_77">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposal_hash</td>
<td><code>T::Hash</code></td>
</tr>
</tbody>
</table>
<h5 id="python_85">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'TechnicalCommittee', 'disapprove_proposal', {'proposal_hash': '[u8; 32]'}
)
</code></pre>
<hr />
<h3 id="events_10">Events</h3>
<hr />
<h4 id="proposed">Proposed</h4>
<p>A motion (given hash) has been proposed (by given account) with a threshold (given
<code>MemberCount</code>).</p>
<h5 id="attributes_78">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>proposal_index</td>
<td><code>ProposalIndex</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>proposal_hash</td>
<td><code>T::Hash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
<tr>
<td>threshold</td>
<td><code>MemberCount</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="voted">Voted</h4>
<p>A motion (given hash) has been voted on by given account, leaving
a tally (yes votes and no votes given respectively as <code>MemberCount</code>).</p>
<h5 id="attributes_79">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>proposal_hash</td>
<td><code>T::Hash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
<tr>
<td>voted</td>
<td><code>bool</code></td>
<td><code>bool</code></td>
</tr>
<tr>
<td>yes</td>
<td><code>MemberCount</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>no</td>
<td><code>MemberCount</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="approved">Approved</h4>
<p>A motion was approved by the required threshold.</p>
<h5 id="attributes_80">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposal_hash</td>
<td><code>T::Hash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="disapproved">Disapproved</h4>
<p>A motion was not approved by the required threshold.</p>
<h5 id="attributes_81">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposal_hash</td>
<td><code>T::Hash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="executed">Executed</h4>
<p>A motion was executed; result will be <code>Ok</code> if it returned without error.</p>
<h5 id="attributes_82">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposal_hash</td>
<td><code>T::Hash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
<tr>
<td>result</td>
<td><code>DispatchResult</code></td>
<td><code>{'Ok': (), 'Err': {'Other': None, 'CannotLookup': None, 'BadOrigin': None, 'Module': {'index': 'u8', 'error': '[u8; 4]'}, 'ConsumerRemaining': None, 'NoProviders': None, 'TooManyConsumers': None, 'Token': ('NoFunds', 'WouldDie', 'BelowMinimum', 'CannotCreate', 'UnknownAsset', 'Frozen', 'Unsupported'), 'Arithmetic': ('Underflow', 'Overflow', 'DivisionByZero'), 'Transactional': ('LimitReached', 'NoLayer')}}</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="memberexecuted">MemberExecuted</h4>
<p>A single member did some action; result will be <code>Ok</code> if it returned without error.</p>
<h5 id="attributes_83">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposal_hash</td>
<td><code>T::Hash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
<tr>
<td>result</td>
<td><code>DispatchResult</code></td>
<td><code>{'Ok': (), 'Err': {'Other': None, 'CannotLookup': None, 'BadOrigin': None, 'Module': {'index': 'u8', 'error': '[u8; 4]'}, 'ConsumerRemaining': None, 'NoProviders': None, 'TooManyConsumers': None, 'Token': ('NoFunds', 'WouldDie', 'BelowMinimum', 'CannotCreate', 'UnknownAsset', 'Frozen', 'Unsupported'), 'Arithmetic': ('Underflow', 'Overflow', 'DivisionByZero'), 'Transactional': ('LimitReached', 'NoLayer')}}</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="closed">Closed</h4>
<p>A proposal was closed because its threshold was reached or after its duration was up.</p>
<h5 id="attributes_84">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>proposal_hash</td>
<td><code>T::Hash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
<tr>
<td>yes</td>
<td><code>MemberCount</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>no</td>
<td><code>MemberCount</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="storage-functions_7">Storage functions</h3>
<hr />
<h4 id="proposals">Proposals</h4>
<p>The hashes of the active proposals.</p>
<h5 id="python_86">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'TechnicalCommittee', 'Proposals', []
)
</code></pre>
<h5 id="return-value_31">Return value</h5>
<pre><code class="language-python">['[u8; 32]']
</code></pre>
<hr />
<h4 id="proposalof">ProposalOf</h4>
<p>Actual proposal for a given hash, if it&#x27;s current.</p>
<h5 id="python_87">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'TechnicalCommittee', 'ProposalOf', ['[u8; 32]']
)
</code></pre>
<h5 id="return-value_32">Return value</h5>
<pre><code class="language-python">'Call'
</code></pre>
<hr />
<h4 id="voting">Voting</h4>
<p>Votes on a given proposal, if it is ongoing.</p>
<h5 id="python_88">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'TechnicalCommittee', 'Voting', ['[u8; 32]']
)
</code></pre>
<h5 id="return-value_33">Return value</h5>
<pre><code class="language-python">{'ayes': ['AccountId'], 'end': 'u32', 'index': 'u32', 'nays': ['AccountId'], 'threshold': 'u32'}
</code></pre>
<hr />
<h4 id="proposalcount">ProposalCount</h4>
<p>Proposals so far.</p>
<h5 id="python_89">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'TechnicalCommittee', 'ProposalCount', []
)
</code></pre>
<h5 id="return-value_34">Return value</h5>
<pre><code class="language-python">'u32'
</code></pre>
<hr />
<h4 id="members">Members</h4>
<p>The current members of the collective. This is stored sorted (just by value).</p>
<h5 id="python_90">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'TechnicalCommittee', 'Members', []
)
</code></pre>
<h5 id="return-value_35">Return value</h5>
<pre><code class="language-python">['AccountId']
</code></pre>
<hr />
<h4 id="prime">Prime</h4>
<p>The prime member that helps determine the default vote behavior in case of absentations.</p>
<h5 id="python_91">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'TechnicalCommittee', 'Prime', []
)
</code></pre>
<h5 id="return-value_36">Return value</h5>
<pre><code class="language-python">'AccountId'
</code></pre>
<hr />
<h3 id="errors_4">Errors</h3>
<hr />
<h4 id="notmember">NotMember</h4>
<p>Account is not a member</p>
<hr />
<h4 id="duplicateproposal">DuplicateProposal</h4>
<p>Duplicate proposals not allowed</p>
<hr />
<h4 id="proposalmissing">ProposalMissing</h4>
<p>Proposal must exist</p>
<hr />
<h4 id="wrongindex">WrongIndex</h4>
<p>Mismatched index</p>
<hr />
<h4 id="duplicatevote">DuplicateVote</h4>
<p>Duplicate vote ignored</p>
<hr />
<h4 id="alreadyinitialized">AlreadyInitialized</h4>
<p>Members are already initialized!</p>
<hr />
<h4 id="tooearly">TooEarly</h4>
<p>The close call was made too early, before the end of the voting.</p>
<hr />
<h4 id="toomanyproposals">TooManyProposals</h4>
<p>There can only be a maximum of <code>MaxProposals</code> active proposals.</p>
<hr />
<h4 id="wrongproposalweight">WrongProposalWeight</h4>
<p>The given weight bound for the proposal was too low.</p>
<hr />
<h4 id="wrongproposallength">WrongProposalLength</h4>
<p>The given length bound for the proposal was too low.</p>
<hr />
<h2 id="technicalmembership">TechnicalMembership</h2>
<hr />
<h3 id="calls_10">Calls</h3>
<hr />
<h4 id="add_member">add_member</h4>
<p>Add a member <code>who</code> to the set.</p>
<p>May only be called from <code>T::AddOrigin</code>.</p>
<h5 id="attributes_85">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_92">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'TechnicalMembership', 'add_member', {'who': 'AccountId'}
)
</code></pre>
<hr />
<h4 id="remove_member">remove_member</h4>
<p>Remove a member <code>who</code> from the set.</p>
<p>May only be called from <code>T::RemoveOrigin</code>.</p>
<h5 id="attributes_86">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_93">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'TechnicalMembership', 'remove_member', {'who': 'AccountId'}
)
</code></pre>
<hr />
<h4 id="swap_member">swap_member</h4>
<p>Swap out one member <code>remove</code> for another <code>add</code>.</p>
<p>May only be called from <code>T::SwapOrigin</code>.</p>
<p>Prime membership is <em>not</em> passed from <code>remove</code> to <code>add</code>, if extant.</p>
<h5 id="attributes_87">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>remove</td>
<td><code>T::AccountId</code></td>
</tr>
<tr>
<td>add</td>
<td><code>T::AccountId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_94">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'TechnicalMembership', 'swap_member', {
    'add': 'AccountId',
    'remove': 'AccountId',
}
)
</code></pre>
<hr />
<h4 id="reset_members">reset_members</h4>
<p>Change the membership to a new set, disregarding the existing membership. Be nice and
pass <code>members</code> pre-sorted.</p>
<p>May only be called from <code>T::ResetOrigin</code>.</p>
<h5 id="attributes_88">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>members</td>
<td><code>Vec&lt;T::AccountId&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_95">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'TechnicalMembership', 'reset_members', {'members': ['AccountId']}
)
</code></pre>
<hr />
<h4 id="change_key">change_key</h4>
<p>Swap out the sending member for some other key <code>new</code>.</p>
<p>May only be called from <code>Signed</code> origin of a current member.</p>
<p>Prime membership is passed from the origin account to <code>new</code>, if extant.</p>
<h5 id="attributes_89">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>new</td>
<td><code>T::AccountId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_96">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'TechnicalMembership', 'change_key', {'new': 'AccountId'}
)
</code></pre>
<hr />
<h4 id="set_prime">set_prime</h4>
<p>Set the prime member. Must be a current member.</p>
<p>May only be called from <code>T::PrimeOrigin</code>.</p>
<h5 id="attributes_90">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_97">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'TechnicalMembership', 'set_prime', {'who': 'AccountId'}
)
</code></pre>
<hr />
<h4 id="clear_prime">clear_prime</h4>
<p>Remove the prime member if it exists.</p>
<p>May only be called from <code>T::PrimeOrigin</code>.</p>
<h5 id="attributes_91">Attributes</h5>
<p>No attributes</p>
<h5 id="python_98">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'TechnicalMembership', 'clear_prime', {}
)
</code></pre>
<hr />
<h3 id="events_11">Events</h3>
<hr />
<h4 id="memberadded">MemberAdded</h4>
<p>The given member was added; see the transaction for who.</p>
<h5 id="attributes_92">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="memberremoved">MemberRemoved</h4>
<p>The given member was removed; see the transaction for who.</p>
<h5 id="attributes_93">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="membersswapped">MembersSwapped</h4>
<p>Two members were swapped; see the transaction for who.</p>
<h5 id="attributes_94">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="membersreset">MembersReset</h4>
<p>The membership was reset; see the transaction for who the new set is.</p>
<h5 id="attributes_95">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="keychanged">KeyChanged</h4>
<p>One of the members&amp;#x27; keys changed.</p>
<h5 id="attributes_96">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="dummy">Dummy</h4>
<p>Phantom member, never used.</p>
<h5 id="attributes_97">Attributes</h5>
<p>No attributes</p>
<hr />
<h3 id="storage-functions_8">Storage functions</h3>
<hr />
<h4 id="members_1">Members</h4>
<p>The current membership, stored as an ordered Vec.</p>
<h5 id="python_99">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'TechnicalMembership', 'Members', []
)
</code></pre>
<h5 id="return-value_37">Return value</h5>
<pre><code class="language-python">['AccountId']
</code></pre>
<hr />
<h4 id="prime_1">Prime</h4>
<p>The current prime member, if one exists.</p>
<h5 id="python_100">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'TechnicalMembership', 'Prime', []
)
</code></pre>
<h5 id="return-value_38">Return value</h5>
<pre><code class="language-python">'AccountId'
</code></pre>
<hr />
<h3 id="errors_5">Errors</h3>
<hr />
<h4 id="alreadymember">AlreadyMember</h4>
<p>Already a member.</p>
<hr />
<h4 id="notmember_1">NotMember</h4>
<p>Not a member.</p>
<hr />
<h4 id="toomanymembers">TooManyMembers</h4>
<p>Too many members.</p>
<hr />
<h2 id="authorship">Authorship</h2>
<hr />
<h3 id="calls_11">Calls</h3>
<hr />
<h4 id="set_uncles">set_uncles</h4>
<p>Provide a set of uncles.</p>
<h5 id="attributes_98">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>new_uncles</td>
<td><code>Vec&lt;T::Header&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_101">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Authorship', 'set_uncles', {
    'new_uncles': [
        {
            'digest': {
                'logs': [
                    {
                        'Other': 'Bytes',
                        None: None,
                        'Consensus': (
                            '[u8; 4]',
                            'Bytes',
                        ),
                        'PreRuntime': (
                            '[u8; 4]',
                            'Bytes',
                        ),
                        'RuntimeEnvironmentUpdated': None,
                        'Seal': (
                            '[u8; 4]',
                            'Bytes',
                        ),
                    },
                ],
            },
            'extrinsics_root': '[u8; 32]',
            'number': 'u32',
            'parent_hash': '[u8; 32]',
            'state_root': '[u8; 32]',
        },
    ],
}
)
</code></pre>
<hr />
<h3 id="storage-functions_9">Storage functions</h3>
<hr />
<h4 id="uncles">Uncles</h4>
<p>Uncles</p>
<h5 id="python_102">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Authorship', 'Uncles', []
)
</code></pre>
<h5 id="return-value_39">Return value</h5>
<pre><code class="language-python">[{'InclusionHeight': 'u32', 'Uncle': ('[u8; 32]', (None, 'AccountId'))}]
</code></pre>
<hr />
<h4 id="author">Author</h4>
<p>Author of current block.</p>
<h5 id="python_103">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Authorship', 'Author', []
)
</code></pre>
<h5 id="return-value_40">Return value</h5>
<pre><code class="language-python">'AccountId'
</code></pre>
<hr />
<h4 id="didsetuncles">DidSetUncles</h4>
<p>Whether uncles were already set in this block.</p>
<h5 id="python_104">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Authorship', 'DidSetUncles', []
)
</code></pre>
<h5 id="return-value_41">Return value</h5>
<pre><code class="language-python">'bool'
</code></pre>
<hr />
<h3 id="constants_6">Constants</h3>
<hr />
<h4 id="unclegenerations">UncleGenerations</h4>
<p>The number of blocks back we should accept uncles.
 This means that we will deal with uncle-parents that are
 <code>UncleGenerations + 1</code> before <code>now</code>.</p>
<h5 id="value_14">Value</h5>
<pre><code class="language-python">0
</code></pre>
<h5 id="python_105">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Authorship', 'UncleGenerations')
</code></pre>
<hr />
<h3 id="errors_6">Errors</h3>
<hr />
<h4 id="invaliduncleparent">InvalidUncleParent</h4>
<p>The uncle parent not in the chain.</p>
<hr />
<h4 id="unclesalreadyset">UnclesAlreadySet</h4>
<p>Uncles already set in the block.</p>
<hr />
<h4 id="toomanyuncles">TooManyUncles</h4>
<p>Too many uncles.</p>
<hr />
<h4 id="genesisuncle">GenesisUncle</h4>
<p>The uncle is genesis.</p>
<hr />
<h4 id="toohighuncle">TooHighUncle</h4>
<p>The uncle is too high in chain.</p>
<hr />
<h4 id="unclealreadyincluded">UncleAlreadyIncluded</h4>
<p>The uncle is already included.</p>
<hr />
<h4 id="olduncle">OldUncle</h4>
<p>The uncle isn&amp;#x27;t recent enough to be included.</p>
<hr />
<h2 id="validatorsset">ValidatorsSet</h2>
<hr />
<h3 id="calls_12">Calls</h3>
<hr />
<h4 id="add_member_1">add_member</h4>
<p>Add a member <code>who</code> to the set.</p>
<p>May only be called from <code>T::AddOrigin</code>.</p>
<h5 id="attributes_99">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_106">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'ValidatorsSet', 'add_member', {'who': 'AccountId'}
)
</code></pre>
<hr />
<h4 id="remove_member_1">remove_member</h4>
<p>Remove a member <code>who</code> from the set.</p>
<p>May only be called from <code>T::RemoveOrigin</code>.</p>
<h5 id="attributes_100">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_107">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'ValidatorsSet', 'remove_member', {'who': 'AccountId'}
)
</code></pre>
<hr />
<h4 id="swap_member_1">swap_member</h4>
<p>Swap out one member <code>remove</code> for another <code>add</code>.</p>
<p>May only be called from <code>T::SwapOrigin</code>.</p>
<p>Prime membership is <em>not</em> passed from <code>remove</code> to <code>add</code>, if extant.</p>
<h5 id="attributes_101">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>remove</td>
<td><code>T::AccountId</code></td>
</tr>
<tr>
<td>add</td>
<td><code>T::AccountId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_108">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'ValidatorsSet', 'swap_member', {
    'add': 'AccountId',
    'remove': 'AccountId',
}
)
</code></pre>
<hr />
<h4 id="reset_members_1">reset_members</h4>
<p>Change the membership to a new set, disregarding the existing membership. Be nice and
pass <code>members</code> pre-sorted.</p>
<p>May only be called from <code>T::ResetOrigin</code>.</p>
<h5 id="attributes_102">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>members</td>
<td><code>Vec&lt;T::AccountId&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_109">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'ValidatorsSet', 'reset_members', {'members': ['AccountId']}
)
</code></pre>
<hr />
<h4 id="change_key_1">change_key</h4>
<p>Swap out the sending member for some other key <code>new</code>.</p>
<p>May only be called from <code>Signed</code> origin of a current member.</p>
<p>Prime membership is passed from the origin account to <code>new</code>, if extant.</p>
<h5 id="attributes_103">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>new</td>
<td><code>T::AccountId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_110">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'ValidatorsSet', 'change_key', {'new': 'AccountId'}
)
</code></pre>
<hr />
<h4 id="set_prime_1">set_prime</h4>
<p>Set the prime member. Must be a current member.</p>
<p>May only be called from <code>T::PrimeOrigin</code>.</p>
<h5 id="attributes_104">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_111">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'ValidatorsSet', 'set_prime', {'who': 'AccountId'}
)
</code></pre>
<hr />
<h4 id="clear_prime_1">clear_prime</h4>
<p>Remove the prime member if it exists.</p>
<p>May only be called from <code>T::PrimeOrigin</code>.</p>
<h5 id="attributes_105">Attributes</h5>
<p>No attributes</p>
<h5 id="python_112">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'ValidatorsSet', 'clear_prime', {}
)
</code></pre>
<hr />
<h3 id="events_12">Events</h3>
<hr />
<h4 id="memberadded_1">MemberAdded</h4>
<p>The given member was added; see the transaction for who.</p>
<h5 id="attributes_106">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="memberremoved_1">MemberRemoved</h4>
<p>The given member was removed; see the transaction for who.</p>
<h5 id="attributes_107">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="membersswapped_1">MembersSwapped</h4>
<p>Two members were swapped; see the transaction for who.</p>
<h5 id="attributes_108">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="membersreset_1">MembersReset</h4>
<p>The membership was reset; see the transaction for who the new set is.</p>
<h5 id="attributes_109">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="keychanged_1">KeyChanged</h4>
<p>One of the members&amp;#x27; keys changed.</p>
<h5 id="attributes_110">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="dummy_1">Dummy</h4>
<p>Phantom member, never used.</p>
<h5 id="attributes_111">Attributes</h5>
<p>No attributes</p>
<hr />
<h3 id="storage-functions_10">Storage functions</h3>
<hr />
<h4 id="members_2">Members</h4>
<p>The current membership, stored as an ordered Vec.</p>
<h5 id="python_113">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ValidatorsSet', 'Members', []
)
</code></pre>
<h5 id="return-value_42">Return value</h5>
<pre><code class="language-python">['AccountId']
</code></pre>
<hr />
<h4 id="prime_2">Prime</h4>
<p>The current prime member, if one exists.</p>
<h5 id="python_114">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ValidatorsSet', 'Prime', []
)
</code></pre>
<h5 id="return-value_43">Return value</h5>
<pre><code class="language-python">'AccountId'
</code></pre>
<hr />
<h3 id="errors_7">Errors</h3>
<hr />
<h4 id="alreadymember_1">AlreadyMember</h4>
<p>Already a member.</p>
<hr />
<h4 id="notmember_2">NotMember</h4>
<p>Not a member.</p>
<hr />
<h4 id="toomanymembers_1">TooManyMembers</h4>
<p>Too many members.</p>
<hr />
<h2 id="poa">Poa</h2>
<hr />
<h3 id="storage-functions_11">Storage functions</h3>
<hr />
<h4 id="storageversion_3">StorageVersion</h4>
<h5 id="python_115">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Poa', 'StorageVersion', []
)
</code></pre>
<h5 id="return-value_44">Return value</h5>
<pre><code class="language-python">('V0', 'V1')
</code></pre>
<hr />
<h2 id="session">Session</h2>
<hr />
<h3 id="calls_13">Calls</h3>
<hr />
<h4 id="set_keys">set_keys</h4>
<p>Sets the session key(s) of the function caller to <code>keys</code>.
Allows an account to set its session key prior to becoming a validator.
This doesn&amp;#x27;t take effect until the next session.</p>
<p>The dispatch origin of this function must be signed.</p>
<p># &lt;weight&gt;
- Complexity: <code>O(1)</code>. Actual cost depends on the number of length of
  <code>T::Keys::key_ids()</code> which is fixed.
- DbReads: <code>origin account</code>, <code>T::ValidatorIdOf</code>, <code>NextKeys</code>
- DbWrites: <code>origin account</code>, <code>NextKeys</code>
- DbReads per key id: <code>KeyOwner</code>
- DbWrites per key id: <code>KeyOwner</code>
# &lt;/weight&gt;</p>
<h5 id="attributes_112">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>keys</td>
<td><code>T::Keys</code></td>
</tr>
<tr>
<td>proof</td>
<td><code>Vec&lt;u8&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_116">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Session', 'set_keys', {'keys': {'aura': '[u8; 32]'}, 'proof': 'Bytes'}
)
</code></pre>
<hr />
<h4 id="purge_keys">purge_keys</h4>
<p>Removes any session key(s) of the function caller.</p>
<p>This doesn&amp;#x27;t take effect until the next session.</p>
<p>The dispatch origin of this function must be Signed and the account must be either be
convertible to a validator ID using the chain&amp;#x27;s typical addressing system (this usually
means being a controller account) or directly convertible into a validator ID (which
usually means being a stash account).</p>
<p># &lt;weight&gt;
- Complexity: <code>O(1)</code> in number of key types. Actual cost depends on the number of length
  of <code>T::Keys::key_ids()</code> which is fixed.
- DbReads: <code>T::ValidatorIdOf</code>, <code>NextKeys</code>, <code>origin account</code>
- DbWrites: <code>NextKeys</code>, <code>origin account</code>
- DbWrites per key id: <code>KeyOwner</code>
# &lt;/weight&gt;</p>
<h5 id="attributes_113">Attributes</h5>
<p>No attributes</p>
<h5 id="python_117">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Session', 'purge_keys', {}
)
</code></pre>
<hr />
<h3 id="events_13">Events</h3>
<hr />
<h4 id="newsession">NewSession</h4>
<p>New session has happened. Note that the argument is the session index, not the
block number as the type might suggest.</p>
<h5 id="attributes_114">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>session_index</td>
<td><code>SessionIndex</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="storage-functions_12">Storage functions</h3>
<hr />
<h4 id="validators">Validators</h4>
<p>The current set of validators.</p>
<h5 id="python_118">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Session', 'Validators', []
)
</code></pre>
<h5 id="return-value_45">Return value</h5>
<pre><code class="language-python">['AccountId']
</code></pre>
<hr />
<h4 id="currentindex">CurrentIndex</h4>
<p>Current index of the session.</p>
<h5 id="python_119">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Session', 'CurrentIndex', []
)
</code></pre>
<h5 id="return-value_46">Return value</h5>
<pre><code class="language-python">'u32'
</code></pre>
<hr />
<h4 id="queuedchanged">QueuedChanged</h4>
<p>True if the underlying economic identities or weighting behind the validators
 has changed in the queued validator set.</p>
<h5 id="python_120">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Session', 'QueuedChanged', []
)
</code></pre>
<h5 id="return-value_47">Return value</h5>
<pre><code class="language-python">'bool'
</code></pre>
<hr />
<h4 id="queuedkeys">QueuedKeys</h4>
<p>The queued keys for the next session. When the next session begins, these keys
 will be used to determine the validator&#x27;s session keys.</p>
<h5 id="python_121">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Session', 'QueuedKeys', []
)
</code></pre>
<h5 id="return-value_48">Return value</h5>
<pre><code class="language-python">[('AccountId', {'aura': '[u8; 32]'})]
</code></pre>
<hr />
<h4 id="disabledvalidators">DisabledValidators</h4>
<p>Indices of disabled validators.</p>
<p>The vec is always kept sorted so that we can find whether a given validator is
 disabled using binary search. It gets cleared when <code>on_session_ending</code> returns
 a new set of identities.</p>
<h5 id="python_122">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Session', 'DisabledValidators', []
)
</code></pre>
<h5 id="return-value_49">Return value</h5>
<pre><code class="language-python">['u32']
</code></pre>
<hr />
<h4 id="nextkeys">NextKeys</h4>
<p>The next session keys for a validator.</p>
<h5 id="python_123">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Session', 'NextKeys', ['AccountId']
)
</code></pre>
<h5 id="return-value_50">Return value</h5>
<pre><code class="language-python">{'aura': '[u8; 32]'}
</code></pre>
<hr />
<h4 id="keyowner">KeyOwner</h4>
<p>The owner of a key. The key is the <code>KeyTypeId</code> + the encoded key.</p>
<h5 id="python_124">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Session', 'KeyOwner', [('[u8; 4]', 'Bytes')]
)
</code></pre>
<h5 id="return-value_51">Return value</h5>
<pre><code class="language-python">'AccountId'
</code></pre>
<hr />
<h3 id="errors_8">Errors</h3>
<hr />
<h4 id="invalidproof">InvalidProof</h4>
<p>Invalid ownership proof.</p>
<hr />
<h4 id="noassociatedvalidatorid">NoAssociatedValidatorId</h4>
<p>No associated validator ID for account.</p>
<hr />
<h4 id="duplicatedkey">DuplicatedKey</h4>
<p>Registered duplicate key.</p>
<hr />
<h4 id="nokeys">NoKeys</h4>
<p>No keys are associated with this account.</p>
<hr />
<h4 id="noaccount">NoAccount</h4>
<p>Key setting account is not live, so it&amp;#x27;s impossible to associate keys.</p>
<hr />
<h2 id="aura">Aura</h2>
<hr />
<h3 id="storage-functions_13">Storage functions</h3>
<hr />
<h4 id="authorities">Authorities</h4>
<p>The current authority set.</p>
<h5 id="python_125">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Aura', 'Authorities', []
)
</code></pre>
<h5 id="return-value_52">Return value</h5>
<pre><code class="language-python">['[u8; 32]']
</code></pre>
<hr />
<h4 id="currentslot">CurrentSlot</h4>
<p>The current slot of this block.</p>
<p>This will be set in <code>on_initialize</code>.</p>
<h5 id="python_126">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Aura', 'CurrentSlot', []
)
</code></pre>
<h5 id="return-value_53">Return value</h5>
<pre><code class="language-python">'u64'
</code></pre>
<hr />
<h2 id="auraext">AuraExt</h2>
<hr />
<h3 id="storage-functions_14">Storage functions</h3>
<hr />
<h4 id="authorities_1">Authorities</h4>
<p>Serves as cache for the authorities.</p>
<p>The authorities in AuRa are overwritten in <code>on_initialize</code> when we switch to a new session,
 but we require the old authorities to verify the seal when validating a PoV. This will always
 be updated to the latest AuRa authorities in <code>on_finalize</code>.</p>
<h5 id="python_127">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'AuraExt', 'Authorities', []
)
</code></pre>
<h5 id="return-value_54">Return value</h5>
<pre><code class="language-python">['[u8; 32]']
</code></pre>
<hr />
<h2 id="parachainsystem">ParachainSystem</h2>
<hr />
<h3 id="calls_14">Calls</h3>
<hr />
<h4 id="set_validation_data">set_validation_data</h4>
<p>Set the current validation data.</p>
<p>This should be invoked exactly once per block. It will panic at the finalization
phase if the call was not invoked.</p>
<p>The dispatch origin for this call must be <code>Inherent</code></p>
<p>As a side effect, this function upgrades the current validation function
if the appropriate time has come.</p>
<h5 id="attributes_115">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td><code>ParachainInherentData</code></td>
</tr>
</tbody>
</table>
<h5 id="python_128">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'ParachainSystem', 'set_validation_data', {
    'data': {
        'downward_messages': [
            {
                'msg': 'Bytes',
                'sent_at': 'u32',
            },
        ],
        'horizontal_messages': 'scale_info::140',
        'relay_chain_state': {
            'trie_nodes': 'scale_info::137',
        },
        'validation_data': {
            'max_pov_size': 'u32',
            'parent_head': 'Bytes',
            'relay_parent_number': 'u32',
            'relay_parent_storage_root': '[u8; 32]',
        },
    },
}
)
</code></pre>
<hr />
<h4 id="sudo_send_upward_message">sudo_send_upward_message</h4>
<h5 id="attributes_116">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>message</td>
<td><code>UpwardMessage</code></td>
</tr>
</tbody>
</table>
<h5 id="python_129">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'ParachainSystem', 'sudo_send_upward_message', {'message': 'Bytes'}
)
</code></pre>
<hr />
<h4 id="authorize_upgrade">authorize_upgrade</h4>
<h5 id="attributes_117">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>code_hash</td>
<td><code>T::Hash</code></td>
</tr>
</tbody>
</table>
<h5 id="python_130">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'ParachainSystem', 'authorize_upgrade', {'code_hash': '[u8; 32]'}
)
</code></pre>
<hr />
<h4 id="enact_authorized_upgrade">enact_authorized_upgrade</h4>
<h5 id="attributes_118">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>code</td>
<td><code>Vec&lt;u8&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_131">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'ParachainSystem', 'enact_authorized_upgrade', {'code': 'Bytes'}
)
</code></pre>
<hr />
<h3 id="events_14">Events</h3>
<hr />
<h4 id="validationfunctionstored">ValidationFunctionStored</h4>
<p>The validation function has been scheduled to apply.</p>
<h5 id="attributes_119">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="validationfunctionapplied">ValidationFunctionApplied</h4>
<p>The validation function was applied as of the contained relay chain block number.</p>
<h5 id="attributes_120">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>relay_chain_block_num</td>
<td><code>RelayChainBlockNumber</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="validationfunctiondiscarded">ValidationFunctionDiscarded</h4>
<p>The relay-chain aborted the upgrade process.</p>
<h5 id="attributes_121">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="upgradeauthorized">UpgradeAuthorized</h4>
<p>An upgrade has been authorized.</p>
<h5 id="attributes_122">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>code_hash</td>
<td><code>T::Hash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="downwardmessagesreceived">DownwardMessagesReceived</h4>
<p>Some downward messages have been received and will be processed.</p>
<h5 id="attributes_123">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td><code>u32</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="downwardmessagesprocessed">DownwardMessagesProcessed</h4>
<p>Downward messages were processed using the given weight.</p>
<h5 id="attributes_124">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>weight_used</td>
<td><code>Weight</code></td>
<td><code>u64</code></td>
</tr>
<tr>
<td>dmq_head</td>
<td><code>relay_chain::Hash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="storage-functions_15">Storage functions</h3>
<hr />
<h4 id="pendingvalidationcode">PendingValidationCode</h4>
<p>In case of a scheduled upgrade, this storage field contains the validation code to be applied.</p>
<p>As soon as the relay chain gives us the go-ahead signal, we will overwrite the <a href="sp_core::storage::well_known_keys::CODE"><code>:code</code></a>
 which will result the next block process with the new validation code. This concludes the upgrade process.</p>
<h5 id="python_132">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'PendingValidationCode', []
)
</code></pre>
<h5 id="return-value_55">Return value</h5>
<pre><code class="language-python">'Bytes'
</code></pre>
<hr />
<h4 id="newvalidationcode">NewValidationCode</h4>
<p>Validation code that is set by the parachain and is to be communicated to collator and
 consequently the relay-chain.</p>
<p>This will be cleared in <code>on_initialize</code> of each new block if no other pallet already set
 the value.</p>
<h5 id="python_133">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'NewValidationCode', []
)
</code></pre>
<h5 id="return-value_56">Return value</h5>
<pre><code class="language-python">'Bytes'
</code></pre>
<hr />
<h4 id="validationdata">ValidationData</h4>
<p>The [<code>PersistedValidationData</code>] set for this block.
 This value is expected to be set only once per block and it&#x27;s never stored
 in the trie.</p>
<h5 id="python_134">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'ValidationData', []
)
</code></pre>
<h5 id="return-value_57">Return value</h5>
<pre><code class="language-python">{
    'max_pov_size': 'u32',
    'parent_head': 'Bytes',
    'relay_parent_number': 'u32',
    'relay_parent_storage_root': '[u8; 32]',
}
</code></pre>
<hr />
<h4 id="didsetvalidationcode">DidSetValidationCode</h4>
<p>Were the validation data set to notify the relay chain?</p>
<h5 id="python_135">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'DidSetValidationCode', []
)
</code></pre>
<h5 id="return-value_58">Return value</h5>
<pre><code class="language-python">'bool'
</code></pre>
<hr />
<h4 id="lastrelaychainblocknumber">LastRelayChainBlockNumber</h4>
<p>The relay chain block number associated with the last parachain block.</p>
<h5 id="python_136">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'LastRelayChainBlockNumber', []
)
</code></pre>
<h5 id="return-value_59">Return value</h5>
<pre><code class="language-python">'u32'
</code></pre>
<hr />
<h4 id="upgraderestrictionsignal">UpgradeRestrictionSignal</h4>
<p>An option which indicates if the relay-chain restricts signalling a validation code upgrade.
 In other words, if this is <code>Some</code> and [<code>NewValidationCode</code>] is <code>Some</code> then the produced
 candidate will be invalid.</p>
<p>This storage item is a mirror of the corresponding value for the current parachain from the
 relay-chain. This value is ephemeral which means it doesn&#x27;t hit the storage. This value is
 set after the inherent.</p>
<h5 id="python_137">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'UpgradeRestrictionSignal', []
)
</code></pre>
<h5 id="return-value_60">Return value</h5>
<pre><code class="language-python">(None, ('Present', ))
</code></pre>
<hr />
<h4 id="relaystateproof">RelayStateProof</h4>
<p>The state proof for the last relay parent block.</p>
<p>This field is meant to be updated each block with the validation data inherent. Therefore,
 before processing of the inherent, e.g. in <code>on_initialize</code> this data may be stale.</p>
<p>This data is also absent from the genesis.</p>
<h5 id="python_138">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'RelayStateProof', []
)
</code></pre>
<h5 id="return-value_61">Return value</h5>
<pre><code class="language-python">{'trie_nodes': 'scale_info::137'}
</code></pre>
<hr />
<h4 id="relevantmessagingstate">RelevantMessagingState</h4>
<p>The snapshot of some state related to messaging relevant to the current parachain as per
 the relay parent.</p>
<p>This field is meant to be updated each block with the validation data inherent. Therefore,
 before processing of the inherent, e.g. in <code>on_initialize</code> this data may be stale.</p>
<p>This data is also absent from the genesis.</p>
<h5 id="python_139">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'RelevantMessagingState', []
)
</code></pre>
<h5 id="return-value_62">Return value</h5>
<pre><code class="language-python">{
    'dmq_mqc_head': '[u8; 32]',
    'egress_channels': [
        (
            'u32',
            {
                'max_capacity': 'u32',
                'max_message_size': 'u32',
                'max_total_size': 'u32',
                'mqc_head': (None, '[u8; 32]'),
                'msg_count': 'u32',
                'total_size': 'u32',
            },
        ),
    ],
    'ingress_channels': [
        (
            'u32',
            {
                'max_capacity': 'u32',
                'max_message_size': 'u32',
                'max_total_size': 'u32',
                'mqc_head': (None, '[u8; 32]'),
                'msg_count': 'u32',
                'total_size': 'u32',
            },
        ),
    ],
    'relay_dispatch_queue_size': ('u32', 'u32'),
}
</code></pre>
<hr />
<h4 id="hostconfiguration">HostConfiguration</h4>
<p>The parachain host configuration that was obtained from the relay parent.</p>
<p>This field is meant to be updated each block with the validation data inherent. Therefore,
 before processing of the inherent, e.g. in <code>on_initialize</code> this data may be stale.</p>
<p>This data is also absent from the genesis.</p>
<h5 id="python_140">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'HostConfiguration', []
)
</code></pre>
<h5 id="return-value_63">Return value</h5>
<pre><code class="language-python">{
    'hrmp_max_message_num_per_candidate': 'u32',
    'max_code_size': 'u32',
    'max_head_data_size': 'u32',
    'max_upward_message_num_per_candidate': 'u32',
    'max_upward_message_size': 'u32',
    'max_upward_queue_count': 'u32',
    'max_upward_queue_size': 'u32',
    'validation_upgrade_cooldown': 'u32',
    'validation_upgrade_delay': 'u32',
}
</code></pre>
<hr />
<h4 id="lastdmqmqchead">LastDmqMqcHead</h4>
<p>The last downward message queue chain head we have observed.</p>
<p>This value is loaded before and saved after processing inbound downward messages carried
 by the system inherent.</p>
<h5 id="python_141">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'LastDmqMqcHead', []
)
</code></pre>
<h5 id="return-value_64">Return value</h5>
<pre><code class="language-python">'[u8; 32]'
</code></pre>
<hr />
<h4 id="lasthrmpmqcheads">LastHrmpMqcHeads</h4>
<p>The message queue chain heads we have observed per each channel incoming channel.</p>
<p>This value is loaded before and saved after processing inbound downward messages carried
 by the system inherent.</p>
<h5 id="python_142">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'LastHrmpMqcHeads', []
)
</code></pre>
<h5 id="return-value_65">Return value</h5>
<pre><code class="language-python">'scale_info::201'
</code></pre>
<hr />
<h4 id="processeddownwardmessages">ProcessedDownwardMessages</h4>
<p>Number of downward messages processed in a block.</p>
<p>This will be cleared in <code>on_initialize</code> of each new block.</p>
<h5 id="python_143">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'ProcessedDownwardMessages', []
)
</code></pre>
<h5 id="return-value_66">Return value</h5>
<pre><code class="language-python">'u32'
</code></pre>
<hr />
<h4 id="hrmpwatermark">HrmpWatermark</h4>
<p>HRMP watermark that was set in a block.</p>
<p>This will be cleared in <code>on_initialize</code> of each new block.</p>
<h5 id="python_144">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'HrmpWatermark', []
)
</code></pre>
<h5 id="return-value_67">Return value</h5>
<pre><code class="language-python">'u32'
</code></pre>
<hr />
<h4 id="hrmpoutboundmessages">HrmpOutboundMessages</h4>
<p>HRMP messages that were sent in a block.</p>
<p>This will be cleared in <code>on_initialize</code> of each new block.</p>
<h5 id="python_145">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'HrmpOutboundMessages', []
)
</code></pre>
<h5 id="return-value_68">Return value</h5>
<pre><code class="language-python">[{'data': 'Bytes', 'recipient': 'u32'}]
</code></pre>
<hr />
<h4 id="upwardmessages">UpwardMessages</h4>
<p>Upward messages that were sent in a block.</p>
<p>This will be cleared in <code>on_initialize</code> of each new block.</p>
<h5 id="python_146">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'UpwardMessages', []
)
</code></pre>
<h5 id="return-value_69">Return value</h5>
<pre><code class="language-python">['Bytes']
</code></pre>
<hr />
<h4 id="pendingupwardmessages">PendingUpwardMessages</h4>
<p>Upward messages that are still pending and not yet send to the relay chain.</p>
<h5 id="python_147">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'PendingUpwardMessages', []
)
</code></pre>
<h5 id="return-value_70">Return value</h5>
<pre><code class="language-python">['Bytes']
</code></pre>
<hr />
<h4 id="announcedhrmpmessagespercandidate">AnnouncedHrmpMessagesPerCandidate</h4>
<p>The number of HRMP messages we observed in <code>on_initialize</code> and thus used that number for
 announcing the weight of <code>on_initialize</code> and <code>on_finalize</code>.</p>
<h5 id="python_148">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'AnnouncedHrmpMessagesPerCandidate', []
)
</code></pre>
<h5 id="return-value_71">Return value</h5>
<pre><code class="language-python">'u32'
</code></pre>
<hr />
<h4 id="reservedxcmpweightoverride">ReservedXcmpWeightOverride</h4>
<p>The weight we reserve at the beginning of the block for processing XCMP messages. This
 overrides the amount set in the Config trait.</p>
<h5 id="python_149">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'ReservedXcmpWeightOverride', []
)
</code></pre>
<h5 id="return-value_72">Return value</h5>
<pre><code class="language-python">'u64'
</code></pre>
<hr />
<h4 id="reserveddmpweightoverride">ReservedDmpWeightOverride</h4>
<p>The weight we reserve at the beginning of the block for processing DMP messages. This
 overrides the amount set in the Config trait.</p>
<h5 id="python_150">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'ReservedDmpWeightOverride', []
)
</code></pre>
<h5 id="return-value_73">Return value</h5>
<pre><code class="language-python">'u64'
</code></pre>
<hr />
<h4 id="authorizedupgrade">AuthorizedUpgrade</h4>
<p>The next authorized upgrade, if there is one.</p>
<h5 id="python_151">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'AuthorizedUpgrade', []
)
</code></pre>
<h5 id="return-value_74">Return value</h5>
<pre><code class="language-python">'[u8; 32]'
</code></pre>
<hr />
<h4 id="customvalidationheaddata">CustomValidationHeadData</h4>
<p>A custom head data that should be returned as result of <code>validate_block</code>.</p>
<p>See [<code>Pallet::set_custom_validation_head_data</code>] for more information.</p>
<h5 id="python_152">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainSystem', 'CustomValidationHeadData', []
)
</code></pre>
<h5 id="return-value_75">Return value</h5>
<pre><code class="language-python">'Bytes'
</code></pre>
<hr />
<h3 id="errors_9">Errors</h3>
<hr />
<h4 id="overlappingupgrades">OverlappingUpgrades</h4>
<p>Attempt to upgrade validation function while existing upgrade pending</p>
<hr />
<h4 id="prohibitedbypolkadot">ProhibitedByPolkadot</h4>
<p>Polkadot currently prohibits this parachain from upgrading its validation function</p>
<hr />
<h4 id="toobig">TooBig</h4>
<p>The supplied validation function has compiled into a blob larger than Polkadot is
willing to run</p>
<hr />
<h4 id="validationdatanotavailable">ValidationDataNotAvailable</h4>
<p>The inherent which supplies the validation data did not run this block</p>
<hr />
<h4 id="hostconfigurationnotavailable">HostConfigurationNotAvailable</h4>
<p>The inherent which supplies the host configuration did not run this block</p>
<hr />
<h4 id="notscheduled">NotScheduled</h4>
<p>No validation function upgrade is currently scheduled.</p>
<hr />
<h4 id="nothingauthorized">NothingAuthorized</h4>
<p>No code upgrade has been authorized.</p>
<hr />
<h4 id="unauthorized">Unauthorized</h4>
<p>The given code upgrade has not been authorized.</p>
<hr />
<h2 id="parachaininfo">ParachainInfo</h2>
<hr />
<h3 id="storage-functions_16">Storage functions</h3>
<hr />
<h4 id="parachainid">ParachainId</h4>
<h5 id="python_153">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'ParachainInfo', 'ParachainId', []
)
</code></pre>
<h5 id="return-value_76">Return value</h5>
<pre><code class="language-python">'u32'
</code></pre>
<hr />
<h2 id="cumulusxcm">CumulusXcm</h2>
<hr />
<h3 id="events_15">Events</h3>
<hr />
<h4 id="invalidformat">InvalidFormat</h4>
<p>Downward message is invalid XCM.
[ id ]</p>
<h5 id="attributes_125">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>[u8; 8]</code></td>
<td><code>[u8; 8]</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="unsupportedversion">UnsupportedVersion</h4>
<p>Downward message is unsupported version of XCM.
[ id ]</p>
<h5 id="attributes_126">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>[u8; 8]</code></td>
<td><code>[u8; 8]</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="executeddownward">ExecutedDownward</h4>
<p>Downward message executed with the given outcome.
[ id, outcome ]</p>
<h5 id="attributes_127">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>[u8; 8]</code></td>
<td><code>[u8; 8]</code></td>
</tr>
<tr>
<td>None</td>
<td><code>Outcome</code></td>
<td><code>{'Complete': 'u64', 'Incomplete': ('u64', {'Overflow': None, 'Unimplemented': None, 'UntrustedReserveLocation': None, 'UntrustedTeleportLocation': None, 'MultiLocationFull': None, 'MultiLocationNotInvertible': None, 'BadOrigin': None, 'InvalidLocation': None, 'AssetNotFound': None, 'FailedToTransactAsset': None, 'NotWithdrawable': None, 'LocationCannotHold': None, 'ExceedsMaxMessageSize': None, 'DestinationUnsupported': None, 'Transport': None, 'Unroutable': None, 'UnknownClaim': None, 'FailedToDecode': None, 'MaxWeightInvalid': None, 'NotHoldingFees': None, 'TooExpensive': None, 'Trap': 'u64', 'UnhandledXcmVersion': None, 'WeightLimitReached': 'u64', 'Barrier': None, 'WeightNotComputable': None}), 'Error': {'Overflow': None, 'Unimplemented': None, 'UntrustedReserveLocation': None, 'UntrustedTeleportLocation': None, 'MultiLocationFull': None, 'MultiLocationNotInvertible': None, 'BadOrigin': None, 'InvalidLocation': None, 'AssetNotFound': None, 'FailedToTransactAsset': None, 'NotWithdrawable': None, 'LocationCannotHold': None, 'ExceedsMaxMessageSize': None, 'DestinationUnsupported': None, 'Transport': None, 'Unroutable': None, 'UnknownClaim': None, 'FailedToDecode': None, 'MaxWeightInvalid': None, 'NotHoldingFees': None, 'TooExpensive': None, 'Trap': 'u64', 'UnhandledXcmVersion': None, 'WeightLimitReached': 'u64', 'Barrier': None, 'WeightNotComputable': None}}</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="utility">Utility</h2>
<hr />
<h3 id="calls_15">Calls</h3>
<hr />
<h4 id="batch">batch</h4>
<p>Send a batch of dispatch calls.</p>
<p>May be called from any origin.</p>
<ul>
<li><code>calls</code>: The calls to be dispatched from the same origin. The number of call must not
  exceed the constant: <code>batched_calls_limit</code> (available in constant metadata).</li>
</ul>
<p>If origin is root then call are dispatch without checking origin filter. (This includes
bypassing <code>frame_system::Config::BaseCallFilter</code>).</p>
<p># &lt;weight&gt;
- Complexity: O(C) where C is the number of calls to be batched.
# &lt;/weight&gt;</p>
<p>This will return <code>Ok</code> in all circumstances. To determine the success of the batch, an
event is deposited. If a call failed and the batch was interrupted, then the
<code>BatchInterrupted</code> event is deposited, along with the number of successful calls made
and the error of the failed call. If all were successful, then the <code>BatchCompleted</code>
event is deposited.</p>
<h5 id="attributes_128">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>calls</td>
<td><code>Vec&lt;&lt;T as Config&gt;::Call&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_154">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Utility', 'batch', {'calls': ['Call']}
)
</code></pre>
<hr />
<h4 id="as_derivative">as_derivative</h4>
<p>Send a call through an indexed pseudonym of the sender.</p>
<p>Filter from origin are passed along. The call will be dispatched with an origin which
use the same filter as the origin of this call.</p>
<p>NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
because you expect <code>proxy</code> to have been used prior in the call stack and you do not want
the call restrictions to apply to any sub-accounts), then use <code>as_multi_threshold_1</code>
in the Multisig pallet instead.</p>
<p>NOTE: Prior to version *12, this was called <code>as_limited_sub</code>.</p>
<p>The dispatch origin for this call must be <em>Signed</em>.</p>
<h5 id="attributes_129">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td><code>u16</code></td>
</tr>
<tr>
<td>call</td>
<td><code>Box&lt;&lt;T as Config&gt;::Call&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_155">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Utility', 'as_derivative', {'call': 'Call', 'index': 'u16'}
)
</code></pre>
<hr />
<h4 id="batch_all">batch_all</h4>
<p>Send a batch of dispatch calls and atomically execute them.
The whole transaction will rollback and fail if any of the calls failed.</p>
<p>May be called from any origin.</p>
<ul>
<li><code>calls</code>: The calls to be dispatched from the same origin. The number of call must not
  exceed the constant: <code>batched_calls_limit</code> (available in constant metadata).</li>
</ul>
<p>If origin is root then call are dispatch without checking origin filter. (This includes
bypassing <code>frame_system::Config::BaseCallFilter</code>).</p>
<p># &lt;weight&gt;
- Complexity: O(C) where C is the number of calls to be batched.
# &lt;/weight&gt;</p>
<h5 id="attributes_130">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>calls</td>
<td><code>Vec&lt;&lt;T as Config&gt;::Call&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_156">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Utility', 'batch_all', {'calls': ['Call']}
)
</code></pre>
<hr />
<h4 id="dispatch_as">dispatch_as</h4>
<p>Dispatches a function call with a provided origin.</p>
<p>The dispatch origin for this call must be <em>Root</em>.</p>
<p># &lt;weight&gt;
- O(1).
- Limited storage reads.
- One DB write (event).
- Weight of derivative <code>call</code> execution + T::WeightInfo::dispatch_as().
# &lt;/weight&gt;</p>
<h5 id="attributes_131">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>as_origin</td>
<td><code>Box&lt;T::PalletsOrigin&gt;</code></td>
</tr>
<tr>
<td>call</td>
<td><code>Box&lt;&lt;T as Config&gt;::Call&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_157">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Utility', 'dispatch_as', {
    'as_origin': {
        'system': {
            'None': None,
            'Root': None,
            'Signed': 'AccountId',
        },
        None: None,
        'CumulusXcm': {
            'Relay': None,
            'SiblingParachain': 'u32',
        },
        'TechnicalCommittee': {
            'Member': 'AccountId',
            'Members': ('u32', 'u32'),
            '_Phantom': None,
        },
        'Void': (),
    },
    'call': 'Call',
}
)
</code></pre>
<hr />
<h4 id="force_batch">force_batch</h4>
<p>Send a batch of dispatch calls.
Unlike <code>batch</code>, it allows errors and won&amp;#x27;t interrupt.</p>
<p>May be called from any origin.</p>
<ul>
<li><code>calls</code>: The calls to be dispatched from the same origin. The number of call must not
  exceed the constant: <code>batched_calls_limit</code> (available in constant metadata).</li>
</ul>
<p>If origin is root then call are dispatch without checking origin filter. (This includes
bypassing <code>frame_system::Config::BaseCallFilter</code>).</p>
<p># &lt;weight&gt;
- Complexity: O(C) where C is the number of calls to be batched.
# &lt;/weight&gt;</p>
<h5 id="attributes_132">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>calls</td>
<td><code>Vec&lt;&lt;T as Config&gt;::Call&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_158">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Utility', 'force_batch', {'calls': ['Call']}
)
</code></pre>
<hr />
<h3 id="events_16">Events</h3>
<hr />
<h4 id="batchinterrupted">BatchInterrupted</h4>
<p>Batch of dispatches did not complete fully. Index of first failing dispatch given, as
well as the error.</p>
<h5 id="attributes_133">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td><code>u32</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>error</td>
<td><code>DispatchError</code></td>
<td><code>{'Other': None, 'CannotLookup': None, 'BadOrigin': None, 'Module': {'index': 'u8', 'error': '[u8; 4]'}, 'ConsumerRemaining': None, 'NoProviders': None, 'TooManyConsumers': None, 'Token': ('NoFunds', 'WouldDie', 'BelowMinimum', 'CannotCreate', 'UnknownAsset', 'Frozen', 'Unsupported'), 'Arithmetic': ('Underflow', 'Overflow', 'DivisionByZero'), 'Transactional': ('LimitReached', 'NoLayer')}</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="batchcompleted">BatchCompleted</h4>
<p>Batch of dispatches completed fully with no error.</p>
<h5 id="attributes_134">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="batchcompletedwitherrors">BatchCompletedWithErrors</h4>
<p>Batch of dispatches completed but has errors.</p>
<h5 id="attributes_135">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="itemcompleted">ItemCompleted</h4>
<p>A single item within a Batch of dispatches has completed with no error.</p>
<h5 id="attributes_136">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="itemfailed">ItemFailed</h4>
<p>A single item within a Batch of dispatches has completed with error.</p>
<h5 id="attributes_137">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>error</td>
<td><code>DispatchError</code></td>
<td><code>{'Other': None, 'CannotLookup': None, 'BadOrigin': None, 'Module': {'index': 'u8', 'error': '[u8; 4]'}, 'ConsumerRemaining': None, 'NoProviders': None, 'TooManyConsumers': None, 'Token': ('NoFunds', 'WouldDie', 'BelowMinimum', 'CannotCreate', 'UnknownAsset', 'Frozen', 'Unsupported'), 'Arithmetic': ('Underflow', 'Overflow', 'DivisionByZero'), 'Transactional': ('LimitReached', 'NoLayer')}</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="dispatchedas">DispatchedAs</h4>
<p>A call was dispatched.</p>
<h5 id="attributes_138">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>result</td>
<td><code>DispatchResult</code></td>
<td><code>{'Ok': (), 'Err': {'Other': None, 'CannotLookup': None, 'BadOrigin': None, 'Module': {'index': 'u8', 'error': '[u8; 4]'}, 'ConsumerRemaining': None, 'NoProviders': None, 'TooManyConsumers': None, 'Token': ('NoFunds', 'WouldDie', 'BelowMinimum', 'CannotCreate', 'UnknownAsset', 'Frozen', 'Unsupported'), 'Arithmetic': ('Underflow', 'Overflow', 'DivisionByZero'), 'Transactional': ('LimitReached', 'NoLayer')}}</code></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="constants_7">Constants</h3>
<hr />
<h4 id="batched_calls_limit">batched_calls_limit</h4>
<p>The limit on the number of batched calls.</p>
<h5 id="value_15">Value</h5>
<pre><code class="language-python">10922
</code></pre>
<h5 id="python_159">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Utility', 'batched_calls_limit')
</code></pre>
<hr />
<h3 id="errors_10">Errors</h3>
<hr />
<h4 id="toomanycalls">TooManyCalls</h4>
<p>Too many calls batched.</p>
<hr />
<h2 id="multisig">Multisig</h2>
<hr />
<h3 id="calls_16">Calls</h3>
<hr />
<h4 id="as_multi_threshold_1">as_multi_threshold_1</h4>
<p>Immediately dispatch a multi-signature call using a single approval from the caller.</p>
<p>The dispatch origin for this call must be <em>Signed</em>.</p>
<ul>
<li><code>other_signatories</code>: The accounts (other than the sender) who are part of the
multi-signature, but do not participate in the approval process.</li>
<li><code>call</code>: The call to be executed.</li>
</ul>
<p>Result is equivalent to the dispatched result.</p>
<p># &lt;weight&gt;
O(Z + C) where Z is the length of the call and C its execution weight.</p>
<hr />
<ul>
<li>DB Weight: None</li>
<li>Plus Call Weight
# &lt;/weight&gt;</li>
</ul>
<h5 id="attributes_139">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>other_signatories</td>
<td><code>Vec&lt;T::AccountId&gt;</code></td>
</tr>
<tr>
<td>call</td>
<td><code>Box&lt;&lt;T as Config&gt;::Call&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_160">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Multisig', 'as_multi_threshold_1', {
    'call': 'Call',
    'other_signatories': ['AccountId'],
}
)
</code></pre>
<hr />
<h4 id="as_multi">as_multi</h4>
<p>Register approval for a dispatch to be made from a deterministic composite account if
approved by a total of <code>threshold - 1</code> of <code>other_signatories</code>.</p>
<p>If there are enough, then dispatch the call.</p>
<p>Payment: <code>DepositBase</code> will be reserved if this is the first approval, plus
<code>threshold</code> times <code>DepositFactor</code>. It is returned once this dispatch happens or
is cancelled.</p>
<p>The dispatch origin for this call must be <em>Signed</em>.</p>
<ul>
<li><code>threshold</code>: The total number of approvals for this dispatch before it is executed.</li>
<li><code>other_signatories</code>: The accounts (other than the sender) who can approve this
dispatch. May not be empty.</li>
<li><code>maybe_timepoint</code>: If this is the first approval, then this must be <code>None</code>. If it is
not the first approval, then it must be <code>Some</code>, with the timepoint (block number and
transaction index) of the first approval transaction.</li>
<li><code>call</code>: The call to be executed.</li>
</ul>
<p>NOTE: Unless this is the final approval, you will generally want to use
<code>approve_as_multi</code> instead, since it only requires a hash of the call.</p>
<p>Result is equivalent to the dispatched result if <code>threshold</code> is exactly <code>1</code>. Otherwise
on success, result is <code>Ok</code> and the result from the interior call, if it was executed,
may be found in the deposited <code>MultisigExecuted</code> event.</p>
<p># &lt;weight&gt;
- <code>O(S + Z + Call)</code>.
- Up to one balance-reserve or unreserve operation.
- One passthrough operation, one insert, both <code>O(S)</code> where <code>S</code> is the number of
  signatories. <code>S</code> is capped by <code>MaxSignatories</code>, with weight being proportional.
- One call encode &amp; hash, both of complexity <code>O(Z)</code> where <code>Z</code> is tx-len.
- One encode &amp; hash, both of complexity <code>O(S)</code>.
- Up to one binary search and insert (<code>O(logS + S)</code>).
- I/O: 1 read <code>O(S)</code>, up to 1 mutate <code>O(S)</code>. Up to one remove.
- One event.
- The weight of the <code>call</code>.
- Storage: inserts one item, value size bounded by <code>MaxSignatories</code>, with a deposit
  taken for its lifetime of <code>DepositBase + threshold * DepositFactor</code>.</p>
<hr />
<ul>
<li>DB Weight:<ul>
<li>Reads: Multisig Storage, [Caller Account], Calls (if <code>store_call</code>)</li>
<li>Writes: Multisig Storage, [Caller Account], Calls (if <code>store_call</code>)</li>
</ul>
</li>
<li>Plus Call Weight
# &lt;/weight&gt;</li>
</ul>
<h5 id="attributes_140">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>threshold</td>
<td><code>u16</code></td>
</tr>
<tr>
<td>other_signatories</td>
<td><code>Vec&lt;T::AccountId&gt;</code></td>
</tr>
<tr>
<td>maybe_timepoint</td>
<td><code>Option&lt;Timepoint&lt;T::BlockNumber&gt;&gt;</code></td>
</tr>
<tr>
<td>call</td>
<td><code>OpaqueCall&lt;T&gt;</code></td>
</tr>
<tr>
<td>store_call</td>
<td><code>bool</code></td>
</tr>
<tr>
<td>max_weight</td>
<td><code>Weight</code></td>
</tr>
</tbody>
</table>
<h5 id="python_161">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Multisig', 'as_multi', {
    'call': 'Call',
    'max_weight': 'u64',
    'maybe_timepoint': (
        None,
        {
            'height': 'u32',
            'index': 'u32',
        },
    ),
    'other_signatories': ['AccountId'],
    'store_call': 'bool',
    'threshold': 'u16',
}
)
</code></pre>
<hr />
<h4 id="approve_as_multi">approve_as_multi</h4>
<p>Register approval for a dispatch to be made from a deterministic composite account if
approved by a total of <code>threshold - 1</code> of <code>other_signatories</code>.</p>
<p>Payment: <code>DepositBase</code> will be reserved if this is the first approval, plus
<code>threshold</code> times <code>DepositFactor</code>. It is returned once this dispatch happens or
is cancelled.</p>
<p>The dispatch origin for this call must be <em>Signed</em>.</p>
<ul>
<li><code>threshold</code>: The total number of approvals for this dispatch before it is executed.</li>
<li><code>other_signatories</code>: The accounts (other than the sender) who can approve this
dispatch. May not be empty.</li>
<li><code>maybe_timepoint</code>: If this is the first approval, then this must be <code>None</code>. If it is
not the first approval, then it must be <code>Some</code>, with the timepoint (block number and
transaction index) of the first approval transaction.</li>
<li><code>call_hash</code>: The hash of the call to be executed.</li>
</ul>
<p>NOTE: If this is the final approval, you will want to use <code>as_multi</code> instead.</p>
<p># &lt;weight&gt;
- <code>O(S)</code>.
- Up to one balance-reserve or unreserve operation.
- One passthrough operation, one insert, both <code>O(S)</code> where <code>S</code> is the number of
  signatories. <code>S</code> is capped by <code>MaxSignatories</code>, with weight being proportional.
- One encode &amp; hash, both of complexity <code>O(S)</code>.
- Up to one binary search and insert (<code>O(logS + S)</code>).
- I/O: 1 read <code>O(S)</code>, up to 1 mutate <code>O(S)</code>. Up to one remove.
- One event.
- Storage: inserts one item, value size bounded by <code>MaxSignatories</code>, with a deposit
  taken for its lifetime of <code>DepositBase + threshold * DepositFactor</code>.</p>
<hr />
<ul>
<li>DB Weight:<ul>
<li>Read: Multisig Storage, [Caller Account]</li>
<li>Write: Multisig Storage, [Caller Account]
# &lt;/weight&gt;</li>
</ul>
</li>
</ul>
<h5 id="attributes_141">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>threshold</td>
<td><code>u16</code></td>
</tr>
<tr>
<td>other_signatories</td>
<td><code>Vec&lt;T::AccountId&gt;</code></td>
</tr>
<tr>
<td>maybe_timepoint</td>
<td><code>Option&lt;Timepoint&lt;T::BlockNumber&gt;&gt;</code></td>
</tr>
<tr>
<td>call_hash</td>
<td><code>[u8; 32]</code></td>
</tr>
<tr>
<td>max_weight</td>
<td><code>Weight</code></td>
</tr>
</tbody>
</table>
<h5 id="python_162">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Multisig', 'approve_as_multi', {
    'call_hash': '[u8; 32]',
    'max_weight': 'u64',
    'maybe_timepoint': (
        None,
        {
            'height': 'u32',
            'index': 'u32',
        },
    ),
    'other_signatories': ['AccountId'],
    'threshold': 'u16',
}
)
</code></pre>
<hr />
<h4 id="cancel_as_multi">cancel_as_multi</h4>
<p>Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
for this operation will be unreserved on success.</p>
<p>The dispatch origin for this call must be <em>Signed</em>.</p>
<ul>
<li><code>threshold</code>: The total number of approvals for this dispatch before it is executed.</li>
<li><code>other_signatories</code>: The accounts (other than the sender) who can approve this
dispatch. May not be empty.</li>
<li><code>timepoint</code>: The timepoint (block number and transaction index) of the first approval
transaction for this dispatch.</li>
<li><code>call_hash</code>: The hash of the call to be executed.</li>
</ul>
<p># &lt;weight&gt;
- <code>O(S)</code>.
- Up to one balance-reserve or unreserve operation.
- One passthrough operation, one insert, both <code>O(S)</code> where <code>S</code> is the number of
  signatories. <code>S</code> is capped by <code>MaxSignatories</code>, with weight being proportional.
- One encode &amp; hash, both of complexity <code>O(S)</code>.
- One event.
- I/O: 1 read <code>O(S)</code>, one remove.
- Storage: removes one item.</p>
<hr />
<ul>
<li>DB Weight:<ul>
<li>Read: Multisig Storage, [Caller Account], Refund Account, Calls</li>
<li>Write: Multisig Storage, [Caller Account], Refund Account, Calls
# &lt;/weight&gt;</li>
</ul>
</li>
</ul>
<h5 id="attributes_142">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>threshold</td>
<td><code>u16</code></td>
</tr>
<tr>
<td>other_signatories</td>
<td><code>Vec&lt;T::AccountId&gt;</code></td>
</tr>
<tr>
<td>timepoint</td>
<td><code>Timepoint&lt;T::BlockNumber&gt;</code></td>
</tr>
<tr>
<td>call_hash</td>
<td><code>[u8; 32]</code></td>
</tr>
</tbody>
</table>
<h5 id="python_163">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Multisig', 'cancel_as_multi', {
    'call_hash': '[u8; 32]',
    'other_signatories': ['AccountId'],
    'threshold': 'u16',
    'timepoint': {
        'height': 'u32',
        'index': 'u32',
    },
}
)
</code></pre>
<hr />
<h3 id="events_17">Events</h3>
<hr />
<h4 id="newmultisig">NewMultisig</h4>
<p>A new multisig operation has begun.</p>
<h5 id="attributes_143">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>approving</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>multisig</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>call_hash</td>
<td><code>CallHash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="multisigapproval">MultisigApproval</h4>
<p>A multisig operation has been approved by someone.</p>
<h5 id="attributes_144">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>approving</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>timepoint</td>
<td><code>Timepoint&lt;T::BlockNumber&gt;</code></td>
<td><code>{'height': 'u32', 'index': 'u32'}</code></td>
</tr>
<tr>
<td>multisig</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>call_hash</td>
<td><code>CallHash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="multisigexecuted">MultisigExecuted</h4>
<p>A multisig operation has been executed.</p>
<h5 id="attributes_145">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>approving</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>timepoint</td>
<td><code>Timepoint&lt;T::BlockNumber&gt;</code></td>
<td><code>{'height': 'u32', 'index': 'u32'}</code></td>
</tr>
<tr>
<td>multisig</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>call_hash</td>
<td><code>CallHash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
<tr>
<td>result</td>
<td><code>DispatchResult</code></td>
<td><code>{'Ok': (), 'Err': {'Other': None, 'CannotLookup': None, 'BadOrigin': None, 'Module': {'index': 'u8', 'error': '[u8; 4]'}, 'ConsumerRemaining': None, 'NoProviders': None, 'TooManyConsumers': None, 'Token': ('NoFunds', 'WouldDie', 'BelowMinimum', 'CannotCreate', 'UnknownAsset', 'Frozen', 'Unsupported'), 'Arithmetic': ('Underflow', 'Overflow', 'DivisionByZero'), 'Transactional': ('LimitReached', 'NoLayer')}}</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="multisigcancelled">MultisigCancelled</h4>
<p>A multisig operation has been cancelled.</p>
<h5 id="attributes_146">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>cancelling</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>timepoint</td>
<td><code>Timepoint&lt;T::BlockNumber&gt;</code></td>
<td><code>{'height': 'u32', 'index': 'u32'}</code></td>
</tr>
<tr>
<td>multisig</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>call_hash</td>
<td><code>CallHash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="storage-functions_17">Storage functions</h3>
<hr />
<h4 id="multisigs">Multisigs</h4>
<p>The set of open multisig operations.</p>
<h5 id="python_164">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Multisig', 'Multisigs', ['AccountId', '[u8; 32]']
)
</code></pre>
<h5 id="return-value_77">Return value</h5>
<pre><code class="language-python">{
    'approvals': ['AccountId'],
    'deposit': 'u128',
    'depositor': 'AccountId',
    'when': {'height': 'u32', 'index': 'u32'},
}
</code></pre>
<hr />
<h4 id="calls_17">Calls</h4>
<h5 id="python_165">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Multisig', 'Calls', ['[u8; 32]']
)
</code></pre>
<h5 id="return-value_78">Return value</h5>
<pre><code class="language-python">('Call', 'AccountId', 'u128')
</code></pre>
<hr />
<h3 id="constants_8">Constants</h3>
<hr />
<h4 id="depositbase">DepositBase</h4>
<p>The base amount of currency needed to reserve for creating a multisig execution or to
 store a dispatch call for later.</p>
<p>This is held for an additional storage item whose value size is
 <code>4 + sizeof((BlockNumber, Balance, AccountId))</code> bytes and whose key size is
 <code>32 + sizeof(AccountId)</code> bytes.</p>
<h5 id="value_16">Value</h5>
<pre><code class="language-python">5430000000
</code></pre>
<h5 id="python_166">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Multisig', 'DepositBase')
</code></pre>
<hr />
<h4 id="depositfactor">DepositFactor</h4>
<p>The amount of currency needed per unit threshold when creating a multisig execution.</p>
<p>This is held for adding 32 bytes more into a pre-existing storage value.</p>
<h5 id="value_17">Value</h5>
<pre><code class="language-python">1920000000
</code></pre>
<h5 id="python_167">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Multisig', 'DepositFactor')
</code></pre>
<hr />
<h4 id="maxsignatories">MaxSignatories</h4>
<p>The maximum amount of signatories allowed in the multisig.</p>
<h5 id="value_18">Value</h5>
<pre><code class="language-python">100
</code></pre>
<h5 id="python_168">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Multisig', 'MaxSignatories')
</code></pre>
<hr />
<h3 id="errors_11">Errors</h3>
<hr />
<h4 id="minimumthreshold">MinimumThreshold</h4>
<p>Threshold must be 2 or greater.</p>
<hr />
<h4 id="alreadyapproved">AlreadyApproved</h4>
<p>Call is already approved by this signatory.</p>
<hr />
<h4 id="noapprovalsneeded">NoApprovalsNeeded</h4>
<p>Call doesn&amp;#x27;t need any (more) approvals.</p>
<hr />
<h4 id="toofewsignatories">TooFewSignatories</h4>
<p>There are too few signatories in the list.</p>
<hr />
<h4 id="toomanysignatories">TooManySignatories</h4>
<p>There are too many signatories in the list.</p>
<hr />
<h4 id="signatoriesoutoforder">SignatoriesOutOfOrder</h4>
<p>The signatories were provided out of order; they should be ordered.</p>
<hr />
<h4 id="senderinsignatories">SenderInSignatories</h4>
<p>The sender was contained in the other signatories; it shouldn&amp;#x27;t be.</p>
<hr />
<h4 id="notfound_1">NotFound</h4>
<p>Multisig operation not found when attempting to cancel.</p>
<hr />
<h4 id="notowner">NotOwner</h4>
<p>Only the account that originally created the multisig is able to cancel it.</p>
<hr />
<h4 id="notimepoint">NoTimepoint</h4>
<p>No timepoint was given, yet the multisig operation is already underway.</p>
<hr />
<h4 id="wrongtimepoint">WrongTimepoint</h4>
<p>A different timepoint was given to the multisig operation that is underway.</p>
<hr />
<h4 id="unexpectedtimepoint">UnexpectedTimepoint</h4>
<p>A timepoint was given, yet no multisig operation is underway.</p>
<hr />
<h4 id="maxweighttoolow">MaxWeightTooLow</h4>
<p>The maximum weight information provided was too low.</p>
<hr />
<h4 id="alreadystored">AlreadyStored</h4>
<p>The data to be stored is already stored.</p>
<hr />
<h2 id="uniques">Uniques</h2>
<hr />
<h3 id="calls_18">Calls</h3>
<hr />
<h4 id="create">create</h4>
<p>Issue a new collection of non-fungible items from a public origin.</p>
<p>This new collection has no items initially and its owner is the origin.</p>
<p>The origin must be Signed and the sender must have sufficient funds free.</p>
<p><code>ItemDeposit</code> funds of sender are reserved.</p>
<p>Parameters:
- <code>collection</code>: The identifier of the new collection. This must not be currently in use.
- <code>admin</code>: The admin of this collection. The admin is the initial address of each
member of the collection&amp;#x27;s admin team.</p>
<p>Emits <code>Created</code> event when successful.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_147">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>admin</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
</tbody>
</table>
<h5 id="python_169">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'create', {
    'admin': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
    'collection': 'u32',
}
)
</code></pre>
<hr />
<h4 id="force_create">force_create</h4>
<p>Issue a new collection of non-fungible items from a privileged origin.</p>
<p>This new collection has no items initially.</p>
<p>The origin must conform to <code>ForceOrigin</code>.</p>
<p>Unlike <code>create</code>, no funds are reserved.</p>
<ul>
<li><code>collection</code>: The identifier of the new item. This must not be currently in use.</li>
<li><code>owner</code>: The owner of this collection of items. The owner has full superuser
  permissions
over this item, but may later change and configure the permissions using
<code>transfer_ownership</code> and <code>set_team</code>.</li>
</ul>
<p>Emits <code>ForceCreated</code> event when successful.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_148">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>owner</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>free_holding</td>
<td><code>bool</code></td>
</tr>
</tbody>
</table>
<h5 id="python_170">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'force_create', {
    'collection': 'u32',
    'free_holding': 'bool',
    'owner': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
}
)
</code></pre>
<hr />
<h4 id="destroy">destroy</h4>
<p>Destroy a collection of fungible items.</p>
<p>The origin must conform to <code>ForceOrigin</code> or must be <code>Signed</code> and the sender must be the
owner of the <code>collection</code>.</p>
<ul>
<li><code>collection</code>: The identifier of the collection to be destroyed.</li>
<li><code>witness</code>: Information on the items minted in the collection. This must be
correct.</li>
</ul>
<p>Emits <code>Destroyed</code> event when successful.</p>
<p>Weight: <code>O(n + m)</code> where:
- <code>n = witness.items</code>
- <code>m = witness.item_metadatas</code>
- <code>a = witness.attributes</code></p>
<h5 id="attributes_149">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>witness</td>
<td><code>DestroyWitness</code></td>
</tr>
</tbody>
</table>
<h5 id="python_171">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'destroy', {
    'collection': 'u32',
    'witness': {
        'attributes': 'u32',
        'item_metadatas': 'u32',
        'items': 'u32',
    },
}
)
</code></pre>
<hr />
<h4 id="mint">mint</h4>
<p>Mint an item of a particular collection.</p>
<p>The origin must be Signed and the sender must be the Issuer of the <code>collection</code>.</p>
<ul>
<li><code>collection</code>: The collection of the item to be minted.</li>
<li><code>item</code>: The item value of the item to be minted.</li>
<li><code>beneficiary</code>: The initial owner of the minted item.</li>
</ul>
<p>Emits <code>Issued</code> event when successful.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_150">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
</tr>
<tr>
<td>owner</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
</tbody>
</table>
<h5 id="python_172">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'mint', {
    'collection': 'u32',
    'item': 'u32',
    'owner': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
}
)
</code></pre>
<hr />
<h4 id="burn">burn</h4>
<p>Destroy a single item.</p>
<p>Origin must be Signed and the sender should be the Admin of the <code>collection</code>.</p>
<ul>
<li><code>collection</code>: The collection of the item to be burned.</li>
<li><code>item</code>: The item of the item to be burned.</li>
<li><code>check_owner</code>: If <code>Some</code> then the operation will fail with <code>WrongOwner</code> unless the
  item is owned by this value.</li>
</ul>
<p>Emits <code>Burned</code> with the actual amount burned.</p>
<p>Weight: <code>O(1)</code>
Modes: <code>check_owner.is_some()</code>.</p>
<h5 id="attributes_151">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
</tr>
<tr>
<td>check_owner</td>
<td><code>Option&lt;&lt;T::Lookup as StaticLookup&gt;::Source&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_173">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'burn', {
    'check_owner': (
        None,
        {
            'Address20': '[u8; 20]',
            'Address32': '[u8; 32]',
            'Id': 'AccountId',
            'Index': (),
            'Raw': 'Bytes',
        },
    ),
    'collection': 'u32',
    'item': 'u32',
}
)
</code></pre>
<hr />
<h4 id="transfer_2">transfer</h4>
<p>Move an item from the sender account to another.</p>
<p>Origin must be Signed and the signing account must be either:
- the Admin of the <code>collection</code>;
- the Owner of the <code>item</code>;
- the approved delegate for the <code>item</code> (in this case, the approval is reset).</p>
<p>Arguments:
- <code>collection</code>: The collection of the item to be transferred.
- <code>item</code>: The item of the item to be transferred.
- <code>dest</code>: The account to receive ownership of the item.</p>
<p>Emits <code>Transferred</code>.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_152">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
</tr>
<tr>
<td>dest</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
</tbody>
</table>
<h5 id="python_174">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'transfer', {
    'collection': 'u32',
    'dest': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
    'item': 'u32',
}
)
</code></pre>
<hr />
<h4 id="redeposit">redeposit</h4>
<p>Reevaluate the deposits on some items.</p>
<p>Origin must be Signed and the sender should be the Owner of the <code>collection</code>.</p>
<ul>
<li><code>collection</code>: The collection to be frozen.</li>
<li><code>items</code>: The items of the collection whose deposits will be reevaluated.</li>
</ul>
<p>NOTE: This exists as a best-effort function. Any items which are unknown or
in the case that the owner account does not have reservable funds to pay for a
deposit increase are ignored. Generally the owner isn&amp;#x27;t going to call this on items
whose existing deposit is less than the refreshed deposit as it would only cost them,
so it&amp;#x27;s of little consequence.</p>
<p>It will still return an error in the case that the collection is unknown of the signer
is not permitted to call it.</p>
<p>Weight: <code>O(items.len())</code></p>
<h5 id="attributes_153">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>items</td>
<td><code>Vec&lt;T::ItemId&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_175">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'redeposit', {'collection': 'u32', 'items': ['u32']}
)
</code></pre>
<hr />
<h4 id="freeze">freeze</h4>
<p>Disallow further unprivileged transfer of an item.</p>
<p>Origin must be Signed and the sender should be the Freezer of the <code>collection</code>.</p>
<ul>
<li><code>collection</code>: The collection of the item to be frozen.</li>
<li><code>item</code>: The item of the item to be frozen.</li>
</ul>
<p>Emits <code>Frozen</code>.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_154">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_176">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'freeze', {'collection': 'u32', 'item': 'u32'}
)
</code></pre>
<hr />
<h4 id="thaw">thaw</h4>
<p>Re-allow unprivileged transfer of an item.</p>
<p>Origin must be Signed and the sender should be the Freezer of the <code>collection</code>.</p>
<ul>
<li><code>collection</code>: The collection of the item to be thawed.</li>
<li><code>item</code>: The item of the item to be thawed.</li>
</ul>
<p>Emits <code>Thawed</code>.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_155">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_177">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'thaw', {'collection': 'u32', 'item': 'u32'}
)
</code></pre>
<hr />
<h4 id="freeze_collection">freeze_collection</h4>
<p>Disallow further unprivileged transfers for a whole collection.</p>
<p>Origin must be Signed and the sender should be the Freezer of the <code>collection</code>.</p>
<ul>
<li><code>collection</code>: The collection to be frozen.</li>
</ul>
<p>Emits <code>CollectionFrozen</code>.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_156">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_178">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'freeze_collection', {'collection': 'u32'}
)
</code></pre>
<hr />
<h4 id="thaw_collection">thaw_collection</h4>
<p>Re-allow unprivileged transfers for a whole collection.</p>
<p>Origin must be Signed and the sender should be the Admin of the <code>collection</code>.</p>
<ul>
<li><code>collection</code>: The collection to be thawed.</li>
</ul>
<p>Emits <code>CollectionThawed</code>.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_157">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_179">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'thaw_collection', {'collection': 'u32'}
)
</code></pre>
<hr />
<h4 id="transfer_ownership">transfer_ownership</h4>
<p>Change the Owner of a collection.</p>
<p>Origin must be Signed and the sender should be the Owner of the <code>collection</code>.</p>
<ul>
<li><code>collection</code>: The collection whose owner should be changed.</li>
<li><code>owner</code>: The new Owner of this collection. They must have called
  <code>set_accept_ownership</code> with <code>collection</code> in order for this operation to succeed.</li>
</ul>
<p>Emits <code>OwnerChanged</code>.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_158">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>owner</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
</tbody>
</table>
<h5 id="python_180">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'transfer_ownership', {
    'collection': 'u32',
    'owner': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
}
)
</code></pre>
<hr />
<h4 id="set_team">set_team</h4>
<p>Change the Issuer, Admin and Freezer of a collection.</p>
<p>Origin must be Signed and the sender should be the Owner of the <code>collection</code>.</p>
<ul>
<li><code>collection</code>: The collection whose team should be changed.</li>
<li><code>issuer</code>: The new Issuer of this collection.</li>
<li><code>admin</code>: The new Admin of this collection.</li>
<li><code>freezer</code>: The new Freezer of this collection.</li>
</ul>
<p>Emits <code>TeamChanged</code>.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_159">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>issuer</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>admin</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>freezer</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
</tbody>
</table>
<h5 id="python_181">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'set_team', {
    'admin': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
    'collection': 'u32',
    'freezer': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
    'issuer': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
}
)
</code></pre>
<hr />
<h4 id="approve_transfer">approve_transfer</h4>
<p>Approve an item to be transferred by a delegated third-party account.</p>
<p>Origin must be Signed and must be the owner of the <code>item</code>.</p>
<ul>
<li><code>collection</code>: The collection of the item to be approved for delegated transfer.</li>
<li><code>item</code>: The item of the item to be approved for delegated transfer.</li>
<li><code>delegate</code>: The account to delegate permission to transfer the item.</li>
</ul>
<p>Emits <code>ApprovedTransfer</code> on success.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_160">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
</tr>
<tr>
<td>delegate</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
</tbody>
</table>
<h5 id="python_182">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'approve_transfer', {
    'collection': 'u32',
    'delegate': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
    'item': 'u32',
}
)
</code></pre>
<hr />
<h4 id="cancel_approval">cancel_approval</h4>
<p>Cancel the prior approval for the transfer of an item by a delegate.</p>
<p>Origin must be either:
- the <code>Force</code> origin;
- <code>Signed</code> with the signer being the Admin of the <code>collection</code>;
- <code>Signed</code> with the signer being the Owner of the <code>item</code>;</p>
<p>Arguments:
- <code>collection</code>: The collection of the item of whose approval will be cancelled.
- <code>item</code>: The item of the item of whose approval will be cancelled.
- <code>maybe_check_delegate</code>: If <code>Some</code> will ensure that the given account is the one to
  which permission of transfer is delegated.</p>
<p>Emits <code>ApprovalCancelled</code> on success.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_161">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
</tr>
<tr>
<td>maybe_check_delegate</td>
<td><code>Option&lt;&lt;T::Lookup as StaticLookup&gt;::Source&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_183">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'cancel_approval', {
    'collection': 'u32',
    'item': 'u32',
    'maybe_check_delegate': (
        None,
        {
            'Address20': '[u8; 20]',
            'Address32': '[u8; 32]',
            'Id': 'AccountId',
            'Index': (),
            'Raw': 'Bytes',
        },
    ),
}
)
</code></pre>
<hr />
<h4 id="force_item_status">force_item_status</h4>
<p>Alter the attributes of a given item.</p>
<p>Origin must be <code>ForceOrigin</code>.</p>
<ul>
<li><code>collection</code>: The identifier of the item.</li>
<li><code>owner</code>: The new Owner of this item.</li>
<li><code>issuer</code>: The new Issuer of this item.</li>
<li><code>admin</code>: The new Admin of this item.</li>
<li><code>freezer</code>: The new Freezer of this item.</li>
<li><code>free_holding</code>: Whether a deposit is taken for holding an item of this collection.</li>
<li><code>is_frozen</code>: Whether this collection is frozen except for permissioned/admin
instructions.</li>
</ul>
<p>Emits <code>ItemStatusChanged</code> with the identity of the item.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_162">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>owner</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>issuer</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>admin</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>freezer</td>
<td><code>&lt;T::Lookup as StaticLookup&gt;::Source</code></td>
</tr>
<tr>
<td>free_holding</td>
<td><code>bool</code></td>
</tr>
<tr>
<td>is_frozen</td>
<td><code>bool</code></td>
</tr>
</tbody>
</table>
<h5 id="python_184">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'force_item_status', {
    'admin': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
    'collection': 'u32',
    'free_holding': 'bool',
    'freezer': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
    'is_frozen': 'bool',
    'issuer': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
    'owner': {
        'Address20': '[u8; 20]',
        'Address32': '[u8; 32]',
        'Id': 'AccountId',
        'Index': (),
        'Raw': 'Bytes',
    },
}
)
</code></pre>
<hr />
<h4 id="set_attribute">set_attribute</h4>
<p>Set an attribute for a collection or item.</p>
<p>Origin must be either <code>ForceOrigin</code> or Signed and the sender should be the Owner of the
<code>collection</code>.</p>
<p>If the origin is Signed, then funds of signer are reserved according to the formula:
<code>MetadataDepositBase + DepositPerByte * (key.len + value.len)</code> taking into
account any already reserved funds.</p>
<ul>
<li><code>collection</code>: The identifier of the collection whose item&amp;#x27;s metadata to set.</li>
<li><code>maybe_item</code>: The identifier of the item whose metadata to set.</li>
<li><code>key</code>: The key of the attribute.</li>
<li><code>value</code>: The value to which to set the attribute.</li>
</ul>
<p>Emits <code>AttributeSet</code>.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_163">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>maybe_item</td>
<td><code>Option&lt;T::ItemId&gt;</code></td>
</tr>
<tr>
<td>key</td>
<td><code>BoundedVec&lt;u8, T::KeyLimit&gt;</code></td>
</tr>
<tr>
<td>value</td>
<td><code>BoundedVec&lt;u8, T::ValueLimit&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_185">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'set_attribute', {
    'collection': 'u32',
    'key': 'Bytes',
    'maybe_item': (None, 'u32'),
    'value': 'Bytes',
}
)
</code></pre>
<hr />
<h4 id="clear_attribute">clear_attribute</h4>
<p>Clear an attribute for a collection or item.</p>
<p>Origin must be either <code>ForceOrigin</code> or Signed and the sender should be the Owner of the
<code>collection</code>.</p>
<p>Any deposit is freed for the collection&amp;#x27;s owner.</p>
<ul>
<li><code>collection</code>: The identifier of the collection whose item&amp;#x27;s metadata to clear.</li>
<li><code>maybe_item</code>: The identifier of the item whose metadata to clear.</li>
<li><code>key</code>: The key of the attribute.</li>
</ul>
<p>Emits <code>AttributeCleared</code>.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_164">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>maybe_item</td>
<td><code>Option&lt;T::ItemId&gt;</code></td>
</tr>
<tr>
<td>key</td>
<td><code>BoundedVec&lt;u8, T::KeyLimit&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_186">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'clear_attribute', {
    'collection': 'u32',
    'key': 'Bytes',
    'maybe_item': (None, 'u32'),
}
)
</code></pre>
<hr />
<h4 id="set_metadata">set_metadata</h4>
<p>Set the metadata for an item.</p>
<p>Origin must be either <code>ForceOrigin</code> or Signed and the sender should be the Owner of the
<code>collection</code>.</p>
<p>If the origin is Signed, then funds of signer are reserved according to the formula:
<code>MetadataDepositBase + DepositPerByte * data.len</code> taking into
account any already reserved funds.</p>
<ul>
<li><code>collection</code>: The identifier of the collection whose item&amp;#x27;s metadata to set.</li>
<li><code>item</code>: The identifier of the item whose metadata to set.</li>
<li><code>data</code>: The general information of this item. Limited in length by <code>StringLimit</code>.</li>
<li><code>is_frozen</code>: Whether the metadata should be frozen against further changes.</li>
</ul>
<p>Emits <code>MetadataSet</code>.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_165">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
</tr>
<tr>
<td>data</td>
<td><code>BoundedVec&lt;u8, T::StringLimit&gt;</code></td>
</tr>
<tr>
<td>is_frozen</td>
<td><code>bool</code></td>
</tr>
</tbody>
</table>
<h5 id="python_187">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'set_metadata', {
    'collection': 'u32',
    'data': 'Bytes',
    'is_frozen': 'bool',
    'item': 'u32',
}
)
</code></pre>
<hr />
<h4 id="clear_metadata">clear_metadata</h4>
<p>Clear the metadata for an item.</p>
<p>Origin must be either <code>ForceOrigin</code> or Signed and the sender should be the Owner of the
<code>item</code>.</p>
<p>Any deposit is freed for the collection&amp;#x27;s owner.</p>
<ul>
<li><code>collection</code>: The identifier of the collection whose item&amp;#x27;s metadata to clear.</li>
<li><code>item</code>: The identifier of the item whose metadata to clear.</li>
</ul>
<p>Emits <code>MetadataCleared</code>.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_166">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_188">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'clear_metadata', {'collection': 'u32', 'item': 'u32'}
)
</code></pre>
<hr />
<h4 id="set_collection_metadata">set_collection_metadata</h4>
<p>Set the metadata for a collection.</p>
<p>Origin must be either <code>ForceOrigin</code> or <code>Signed</code> and the sender should be the Owner of
the <code>collection</code>.</p>
<p>If the origin is <code>Signed</code>, then funds of signer are reserved according to the formula:
<code>MetadataDepositBase + DepositPerByte * data.len</code> taking into
account any already reserved funds.</p>
<ul>
<li><code>collection</code>: The identifier of the item whose metadata to update.</li>
<li><code>data</code>: The general information of this item. Limited in length by <code>StringLimit</code>.</li>
<li><code>is_frozen</code>: Whether the metadata should be frozen against further changes.</li>
</ul>
<p>Emits <code>CollectionMetadataSet</code>.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_167">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>data</td>
<td><code>BoundedVec&lt;u8, T::StringLimit&gt;</code></td>
</tr>
<tr>
<td>is_frozen</td>
<td><code>bool</code></td>
</tr>
</tbody>
</table>
<h5 id="python_189">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'set_collection_metadata', {
    'collection': 'u32',
    'data': 'Bytes',
    'is_frozen': 'bool',
}
)
</code></pre>
<hr />
<h4 id="clear_collection_metadata">clear_collection_metadata</h4>
<p>Clear the metadata for a collection.</p>
<p>Origin must be either <code>ForceOrigin</code> or <code>Signed</code> and the sender should be the Owner of
the <code>collection</code>.</p>
<p>Any deposit is freed for the collection&amp;#x27;s owner.</p>
<ul>
<li><code>collection</code>: The identifier of the collection whose metadata to clear.</li>
</ul>
<p>Emits <code>CollectionMetadataCleared</code>.</p>
<p>Weight: <code>O(1)</code></p>
<h5 id="attributes_168">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_190">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'clear_collection_metadata', {'collection': 'u32'}
)
</code></pre>
<hr />
<h4 id="set_accept_ownership">set_accept_ownership</h4>
<p>Set (or reset) the acceptance of ownership for a particular account.</p>
<p>Origin must be <code>Signed</code> and if <code>maybe_collection</code> is <code>Some</code>, then the signer must have a
provider reference.</p>
<ul>
<li><code>maybe_collection</code>: The identifier of the collection whose ownership the signer is
  willing to accept, or if <code>None</code>, an indication that the signer is willing to accept no
  ownership transferal.</li>
</ul>
<p>Emits <code>OwnershipAcceptanceChanged</code>.</p>
<h5 id="attributes_169">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>maybe_collection</td>
<td><code>Option&lt;T::CollectionId&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_191">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'set_accept_ownership', {'maybe_collection': (None, 'u32')}
)
</code></pre>
<hr />
<h4 id="set_collection_max_supply">set_collection_max_supply</h4>
<p>Set the maximum amount of items a collection could have.</p>
<p>Origin must be either <code>ForceOrigin</code> or <code>Signed</code> and the sender should be the Owner of
the <code>collection</code>.</p>
<p>Note: This function can only succeed once per collection.</p>
<ul>
<li><code>collection</code>: The identifier of the collection to change.</li>
<li><code>max_supply</code>: The maximum amount of items a collection could have.</li>
</ul>
<p>Emits <code>CollectionMaxSupplySet</code> event when successful.</p>
<h5 id="attributes_170">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
</tr>
<tr>
<td>max_supply</td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<h5 id="python_192">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Uniques', 'set_collection_max_supply', {
    'collection': 'u32',
    'max_supply': 'u32',
}
)
</code></pre>
<hr />
<h3 id="events_18">Events</h3>
<hr />
<h4 id="created">Created</h4>
<p>A <code>collection</code> was created.</p>
<h5 id="attributes_171">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>creator</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>owner</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="forcecreated">ForceCreated</h4>
<p>A <code>collection</code> was force-created.</p>
<h5 id="attributes_172">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>owner</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="destroyed">Destroyed</h4>
<p>A <code>collection</code> was destroyed.</p>
<h5 id="attributes_173">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="issued">Issued</h4>
<p>An <code>item</code> was issued.</p>
<h5 id="attributes_174">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>owner</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="transferred">Transferred</h4>
<p>An <code>item</code> was transferred.</p>
<h5 id="attributes_175">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>from</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>to</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="burned">Burned</h4>
<p>An <code>item</code> was destroyed.</p>
<h5 id="attributes_176">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>owner</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="frozen">Frozen</h4>
<p>Some <code>item</code> was frozen.</p>
<h5 id="attributes_177">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="thawed">Thawed</h4>
<p>Some <code>item</code> was thawed.</p>
<h5 id="attributes_178">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="collectionfrozen">CollectionFrozen</h4>
<p>Some <code>collection</code> was frozen.</p>
<h5 id="attributes_179">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="collectionthawed">CollectionThawed</h4>
<p>Some <code>collection</code> was thawed.</p>
<h5 id="attributes_180">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="ownerchanged">OwnerChanged</h4>
<p>The owner changed.</p>
<h5 id="attributes_181">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>new_owner</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="teamchanged">TeamChanged</h4>
<p>The management team changed.</p>
<h5 id="attributes_182">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>issuer</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>admin</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>freezer</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="approvedtransfer">ApprovedTransfer</h4>
<p>An <code>item</code> of a <code>collection</code> has been approved by the <code>owner</code> for transfer by
a <code>delegate</code>.</p>
<h5 id="attributes_183">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>owner</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>delegate</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="approvalcancelled">ApprovalCancelled</h4>
<p>An approval for a <code>delegate</code> account to transfer the <code>item</code> of an item
<code>collection</code> was cancelled by its <code>owner</code>.</p>
<h5 id="attributes_184">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>owner</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>delegate</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="itemstatuschanged">ItemStatusChanged</h4>
<p>A <code>collection</code> has had its attributes changed by the <code>Force</code> origin.</p>
<h5 id="attributes_185">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="collectionmetadataset">CollectionMetadataSet</h4>
<p>New metadata has been set for a <code>collection</code>.</p>
<h5 id="attributes_186">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>data</td>
<td><code>BoundedVec&lt;u8, T::StringLimit&gt;</code></td>
<td><code>Bytes</code></td>
</tr>
<tr>
<td>is_frozen</td>
<td><code>bool</code></td>
<td><code>bool</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="collectionmetadatacleared">CollectionMetadataCleared</h4>
<p>Metadata has been cleared for a <code>collection</code>.</p>
<h5 id="attributes_187">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="metadataset">MetadataSet</h4>
<p>New metadata has been set for an item.</p>
<h5 id="attributes_188">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>data</td>
<td><code>BoundedVec&lt;u8, T::StringLimit&gt;</code></td>
<td><code>Bytes</code></td>
</tr>
<tr>
<td>is_frozen</td>
<td><code>bool</code></td>
<td><code>bool</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="metadatacleared">MetadataCleared</h4>
<p>Metadata has been cleared for an item.</p>
<h5 id="attributes_189">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>item</td>
<td><code>T::ItemId</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="redeposited">Redeposited</h4>
<p>Metadata has been cleared for an item.</p>
<h5 id="attributes_190">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>successful_items</td>
<td><code>Vec&lt;T::ItemId&gt;</code></td>
<td><code>['u32']</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="attributeset">AttributeSet</h4>
<p>New attribute metadata has been set for a <code>collection</code> or <code>item</code>.</p>
<h5 id="attributes_191">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>maybe_item</td>
<td><code>Option&lt;T::ItemId&gt;</code></td>
<td><code>(None, 'u32')</code></td>
</tr>
<tr>
<td>key</td>
<td><code>BoundedVec&lt;u8, T::KeyLimit&gt;</code></td>
<td><code>Bytes</code></td>
</tr>
<tr>
<td>value</td>
<td><code>BoundedVec&lt;u8, T::ValueLimit&gt;</code></td>
<td><code>Bytes</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="attributecleared">AttributeCleared</h4>
<p>Attribute metadata has been cleared for a <code>collection</code> or <code>item</code>.</p>
<h5 id="attributes_192">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>maybe_item</td>
<td><code>Option&lt;T::ItemId&gt;</code></td>
<td><code>(None, 'u32')</code></td>
</tr>
<tr>
<td>key</td>
<td><code>BoundedVec&lt;u8, T::KeyLimit&gt;</code></td>
<td><code>Bytes</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="ownershipacceptancechanged">OwnershipAcceptanceChanged</h4>
<p>Ownership acceptance has changed for an account.</p>
<h5 id="attributes_193">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
<td><code>AccountId</code></td>
</tr>
<tr>
<td>maybe_collection</td>
<td><code>Option&lt;T::CollectionId&gt;</code></td>
<td><code>(None, 'u32')</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="collectionmaxsupplyset">CollectionMaxSupplySet</h4>
<p>Max supply has been set for a collection.</p>
<h5 id="attributes_194">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td><code>T::CollectionId</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>max_supply</td>
<td><code>u32</code></td>
<td><code>u32</code></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="storage-functions_18">Storage functions</h3>
<hr />
<h4 id="class">Class</h4>
<p>Details of a collection.</p>
<h5 id="python_193">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Uniques', 'Class', ['u32']
)
</code></pre>
<h5 id="return-value_79">Return value</h5>
<pre><code class="language-python">{
    'admin': 'AccountId',
    'attributes': 'u32',
    'free_holding': 'bool',
    'freezer': 'AccountId',
    'is_frozen': 'bool',
    'issuer': 'AccountId',
    'item_metadatas': 'u32',
    'items': 'u32',
    'owner': 'AccountId',
    'total_deposit': 'u128',
}
</code></pre>
<hr />
<h4 id="ownershipacceptance">OwnershipAcceptance</h4>
<p>The collection, if any, of which an account is willing to take ownership.</p>
<h5 id="python_194">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Uniques', 'OwnershipAcceptance', ['AccountId']
)
</code></pre>
<h5 id="return-value_80">Return value</h5>
<pre><code class="language-python">'u32'
</code></pre>
<hr />
<h4 id="account_2">Account</h4>
<p>The items held by any given account; set out this way so that items owned by a single
 account can be enumerated.</p>
<h5 id="python_195">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Uniques', 'Account', ['AccountId', 'u32', 'u32']
)
</code></pre>
<h5 id="return-value_81">Return value</h5>
<pre><code class="language-python">()
</code></pre>
<hr />
<h4 id="classaccount">ClassAccount</h4>
<p>The collections owned by any given account; set out this way so that collections owned by
 a single account can be enumerated.</p>
<h5 id="python_196">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Uniques', 'ClassAccount', ['AccountId', 'u32']
)
</code></pre>
<h5 id="return-value_82">Return value</h5>
<pre><code class="language-python">()
</code></pre>
<hr />
<h4 id="asset">Asset</h4>
<p>The items in existence and their ownership details.</p>
<h5 id="python_197">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Uniques', 'Asset', ['u32', 'u32']
)
</code></pre>
<h5 id="return-value_83">Return value</h5>
<pre><code class="language-python">{'approved': (None, 'AccountId'), 'deposit': 'u128', 'is_frozen': 'bool', 'owner': 'AccountId'}
</code></pre>
<hr />
<h4 id="classmetadataof">ClassMetadataOf</h4>
<p>Metadata of a collection.</p>
<h5 id="python_198">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Uniques', 'ClassMetadataOf', ['u32']
)
</code></pre>
<h5 id="return-value_84">Return value</h5>
<pre><code class="language-python">{'data': 'Bytes', 'deposit': 'u128', 'is_frozen': 'bool'}
</code></pre>
<hr />
<h4 id="instancemetadataof">InstanceMetadataOf</h4>
<p>Metadata of an item.</p>
<h5 id="python_199">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Uniques', 'InstanceMetadataOf', ['u32', 'u32']
)
</code></pre>
<h5 id="return-value_85">Return value</h5>
<pre><code class="language-python">{'data': 'Bytes', 'deposit': 'u128', 'is_frozen': 'bool'}
</code></pre>
<hr />
<h4 id="attribute">Attribute</h4>
<p>Attributes of a collection.</p>
<h5 id="python_200">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Uniques', 'Attribute', ['u32', (None, 'u32'), 'Bytes']
)
</code></pre>
<h5 id="return-value_86">Return value</h5>
<pre><code class="language-python">('Bytes', 'u128')
</code></pre>
<hr />
<h4 id="collectionmaxsupply">CollectionMaxSupply</h4>
<p>Keeps track of the number of items a collection might have.</p>
<h5 id="python_201">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Uniques', 'CollectionMaxSupply', ['u32']
)
</code></pre>
<h5 id="return-value_87">Return value</h5>
<pre><code class="language-python">'u32'
</code></pre>
<hr />
<h3 id="constants_9">Constants</h3>
<hr />
<h4 id="collectiondeposit">CollectionDeposit</h4>
<p>The basic amount of funds that must be reserved for collection.</p>
<h5 id="value_19">Value</h5>
<pre><code class="language-python">10000000000000
</code></pre>
<h5 id="python_202">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Uniques', 'CollectionDeposit')
</code></pre>
<hr />
<h4 id="itemdeposit">ItemDeposit</h4>
<p>The basic amount of funds that must be reserved for an item.</p>
<h5 id="value_20">Value</h5>
<pre><code class="language-python">100000000000
</code></pre>
<h5 id="python_203">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Uniques', 'ItemDeposit')
</code></pre>
<hr />
<h4 id="metadatadepositbase">MetadataDepositBase</h4>
<p>The basic amount of funds that must be reserved when adding metadata to your item.</p>
<h5 id="value_21">Value</h5>
<pre><code class="language-python">10000000000
</code></pre>
<h5 id="python_204">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Uniques', 'MetadataDepositBase')
</code></pre>
<hr />
<h4 id="attributedepositbase">AttributeDepositBase</h4>
<p>The basic amount of funds that must be reserved when adding an attribute to an item.</p>
<h5 id="value_22">Value</h5>
<pre><code class="language-python">10000000000
</code></pre>
<h5 id="python_205">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Uniques', 'AttributeDepositBase')
</code></pre>
<hr />
<h4 id="depositperbyte">DepositPerByte</h4>
<p>The additional funds that must be reserved for the number of bytes store in metadata,
 either &quot;normal&quot; metadata or attribute metadata.</p>
<h5 id="value_23">Value</h5>
<pre><code class="language-python">1000000000
</code></pre>
<h5 id="python_206">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Uniques', 'DepositPerByte')
</code></pre>
<hr />
<h4 id="stringlimit">StringLimit</h4>
<p>The maximum length of data stored on-chain.</p>
<h5 id="value_24">Value</h5>
<pre><code class="language-python">50
</code></pre>
<h5 id="python_207">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Uniques', 'StringLimit')
</code></pre>
<hr />
<h4 id="keylimit">KeyLimit</h4>
<p>The maximum length of an attribute key.</p>
<h5 id="value_25">Value</h5>
<pre><code class="language-python">32
</code></pre>
<h5 id="python_208">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Uniques', 'KeyLimit')
</code></pre>
<hr />
<h4 id="valuelimit">ValueLimit</h4>
<p>The maximum length of an attribute value.</p>
<h5 id="value_26">Value</h5>
<pre><code class="language-python">256
</code></pre>
<h5 id="python_209">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Uniques', 'ValueLimit')
</code></pre>
<hr />
<h3 id="errors_12">Errors</h3>
<hr />
<h4 id="nopermission">NoPermission</h4>
<p>The signing account has no permission to do the operation.</p>
<hr />
<h4 id="unknowncollection">UnknownCollection</h4>
<p>The given item ID is unknown.</p>
<hr />
<h4 id="alreadyexists">AlreadyExists</h4>
<p>The item ID has already been used for an item.</p>
<hr />
<h4 id="wrongowner">WrongOwner</h4>
<p>The owner turned out to be different to what was expected.</p>
<hr />
<h4 id="badwitness">BadWitness</h4>
<p>Invalid witness data given.</p>
<hr />
<h4 id="inuse">InUse</h4>
<p>The item ID is already taken.</p>
<hr />
<h4 id="frozen_1">Frozen</h4>
<p>The item or collection is frozen.</p>
<hr />
<h4 id="wrongdelegate">WrongDelegate</h4>
<p>The delegate turned out to be different to what was expected.</p>
<hr />
<h4 id="nodelegate">NoDelegate</h4>
<p>There is no delegate approved.</p>
<hr />
<h4 id="unapproved">Unapproved</h4>
<p>No approval exists that would allow the transfer.</p>
<hr />
<h4 id="unaccepted">Unaccepted</h4>
<p>The named owner has not signed ownership of the collection is acceptable.</p>
<hr />
<h4 id="locked">Locked</h4>
<p>The item is locked.</p>
<hr />
<h4 id="maxsupplyreached">MaxSupplyReached</h4>
<p>All items have been minted.</p>
<hr />
<h4 id="maxsupplyalreadyset">MaxSupplyAlreadySet</h4>
<p>The max supply has already been set.</p>
<hr />
<h4 id="maxsupplytoosmall">MaxSupplyTooSmall</h4>
<p>The provided max supply is less to the amount of items a collection already has.</p>
<hr />
<h2 id="preimage">Preimage</h2>
<hr />
<h3 id="calls_19">Calls</h3>
<hr />
<h4 id="note_preimage">note_preimage</h4>
<p>Register a preimage on-chain.</p>
<p>If the preimage was previously requested, no fees or deposits are taken for providing
the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.</p>
<h5 id="attributes_195">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>bytes</td>
<td><code>Vec&lt;u8&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_210">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Preimage', 'note_preimage', {'bytes': 'Bytes'}
)
</code></pre>
<hr />
<h4 id="unnote_preimage">unnote_preimage</h4>
<p>Clear an unrequested preimage from the runtime storage.</p>
<h5 id="attributes_196">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td><code>T::Hash</code></td>
</tr>
</tbody>
</table>
<h5 id="python_211">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Preimage', 'unnote_preimage', {'hash': '[u8; 32]'}
)
</code></pre>
<hr />
<h4 id="request_preimage">request_preimage</h4>
<p>Request a preimage be uploaded to the chain without paying any fees or deposits.</p>
<p>If the preimage requests has already been provided on-chain, we unreserve any deposit
a user may have paid, and take the control of the preimage out of their hands.</p>
<h5 id="attributes_197">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td><code>T::Hash</code></td>
</tr>
</tbody>
</table>
<h5 id="python_212">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Preimage', 'request_preimage', {'hash': '[u8; 32]'}
)
</code></pre>
<hr />
<h4 id="unrequest_preimage">unrequest_preimage</h4>
<p>Clear a previously made request for a preimage.</p>
<p>NOTE: THIS MUST NOT BE CALLED ON <code>hash</code> MORE TIMES THAN <code>request_preimage</code>.</p>
<h5 id="attributes_198">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td><code>T::Hash</code></td>
</tr>
</tbody>
</table>
<h5 id="python_213">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Preimage', 'unrequest_preimage', {'hash': '[u8; 32]'}
)
</code></pre>
<hr />
<h3 id="events_19">Events</h3>
<hr />
<h4 id="noted">Noted</h4>
<p>A preimage has been noted.</p>
<h5 id="attributes_199">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td><code>T::Hash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="requested">Requested</h4>
<p>A preimage has been requested.</p>
<h5 id="attributes_200">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td><code>T::Hash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
</tbody>
</table>
<hr />
<h4 id="cleared">Cleared</h4>
<p>A preimage has ben cleared.</p>
<h5 id="attributes_201">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td><code>T::Hash</code></td>
<td><code>[u8; 32]</code></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="storage-functions_19">Storage functions</h3>
<hr />
<h4 id="statusfor">StatusFor</h4>
<p>The request status of a given hash.</p>
<h5 id="python_214">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Preimage', 'StatusFor', ['[u8; 32]']
)
</code></pre>
<h5 id="return-value_88">Return value</h5>
<pre><code class="language-python">{'Requested': 'u32', 'Unrequested': (None, ('AccountId', 'u128'))}
</code></pre>
<hr />
<h4 id="preimagefor">PreimageFor</h4>
<p>The preimages stored by this pallet.</p>
<h5 id="python_215">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Preimage', 'PreimageFor', ['[u8; 32]']
)
</code></pre>
<h5 id="return-value_89">Return value</h5>
<pre><code class="language-python">'Bytes'
</code></pre>
<hr />
<h3 id="errors_13">Errors</h3>
<hr />
<h4 id="toolarge">TooLarge</h4>
<p>Preimage is too large to store on-chain.</p>
<hr />
<h4 id="alreadynoted">AlreadyNoted</h4>
<p>Preimage has already been noted on-chain.</p>
<hr />
<h4 id="notauthorized">NotAuthorized</h4>
<p>The user is not authorized to perform this action.</p>
<hr />
<h4 id="notnoted">NotNoted</h4>
<p>The preimage cannot be removed since it has not yet been noted.</p>
<hr />
<h4 id="requested_1">Requested</h4>
<p>A preimage may not be removed when there are outstanding requests.</p>
<hr />
<h4 id="notrequested">NotRequested</h4>
<p>The preimage request cannot be removed since no outstanding requests exist.</p>
<hr />
<h2 id="allocations">Allocations</h2>
<hr />
<h3 id="calls_20">Calls</h3>
<hr />
<h4 id="batch_1">batch</h4>
<p>Optimized allocation call, which will batch allocations of various amounts
and destinations and together. This allow us to be much more efficient and thus
increase our chain&amp;#x27;s capacity in handling these transactions.</p>
<h5 id="attributes_202">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>batch</td>
<td><code>BoundedVec&lt;(T::AccountId, BalanceOf&lt;T&gt;), T::MaxAllocs&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_216">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'Allocations', 'batch', {'batch': [('AccountId', 'u128')]}
)
</code></pre>
<hr />
<h3 id="storage-functions_20">Storage functions</h3>
<hr />
<h4 id="storageversion_4">StorageVersion</h4>
<h5 id="python_217">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'Allocations', 'StorageVersion', []
)
</code></pre>
<h5 id="return-value_90">Return value</h5>
<pre><code class="language-python">('V0', 'V1')
</code></pre>
<hr />
<h3 id="constants_10">Constants</h3>
<hr />
<h4 id="protocolfee">ProtocolFee</h4>
<h5 id="value_27">Value</h5>
<pre><code class="language-python">200000000
</code></pre>
<h5 id="python_218">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Allocations', 'ProtocolFee')
</code></pre>
<hr />
<h4 id="maximumsupply">MaximumSupply</h4>
<h5 id="value_28">Value</h5>
<pre><code class="language-python">2100000000000000000000
</code></pre>
<h5 id="python_219">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Allocations', 'MaximumSupply')
</code></pre>
<hr />
<h4 id="existentialdeposit_2">ExistentialDeposit</h4>
<p>Runtime existential deposit</p>
<h5 id="value_29">Value</h5>
<pre><code class="language-python">10000
</code></pre>
<h5 id="python_220">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Allocations', 'ExistentialDeposit')
</code></pre>
<hr />
<h4 id="maxallocs">MaxAllocs</h4>
<p>How big a batch can be</p>
<h5 id="value_30">Value</h5>
<pre><code class="language-python">500
</code></pre>
<h5 id="python_221">Python</h5>
<pre><code class="language-python">constant = substrate.get_constant('Allocations', 'MaxAllocs')
</code></pre>
<hr />
<h3 id="errors_14">Errors</h3>
<hr />
<h4 id="oracleaccessdenied">OracleAccessDenied</h4>
<p>Function is restricted to oracles only</p>
<hr />
<h4 id="toomanycoinstoallocate">TooManyCoinsToAllocate</h4>
<p>We are trying to allocate more coins than we can</p>
<hr />
<h4 id="doesnotsatisfyexistentialdeposit">DoesNotSatisfyExistentialDeposit</h4>
<p>Amount is too low and will conflict with the ExistentialDeposit parameter</p>
<hr />
<h4 id="batchempty">BatchEmpty</h4>
<p>Batch is empty or no issuance is necessary</p>
<hr />
<h2 id="allocationsoracles">AllocationsOracles</h2>
<hr />
<h3 id="calls_21">Calls</h3>
<hr />
<h4 id="add_member_2">add_member</h4>
<p>Add a member <code>who</code> to the set.</p>
<p>May only be called from <code>T::AddOrigin</code>.</p>
<h5 id="attributes_203">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_222">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'AllocationsOracles', 'add_member', {'who': 'AccountId'}
)
</code></pre>
<hr />
<h4 id="remove_member_2">remove_member</h4>
<p>Remove a member <code>who</code> from the set.</p>
<p>May only be called from <code>T::RemoveOrigin</code>.</p>
<h5 id="attributes_204">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_223">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'AllocationsOracles', 'remove_member', {'who': 'AccountId'}
)
</code></pre>
<hr />
<h4 id="swap_member_2">swap_member</h4>
<p>Swap out one member <code>remove</code> for another <code>add</code>.</p>
<p>May only be called from <code>T::SwapOrigin</code>.</p>
<p>Prime membership is <em>not</em> passed from <code>remove</code> to <code>add</code>, if extant.</p>
<h5 id="attributes_205">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>remove</td>
<td><code>T::AccountId</code></td>
</tr>
<tr>
<td>add</td>
<td><code>T::AccountId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_224">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'AllocationsOracles', 'swap_member', {
    'add': 'AccountId',
    'remove': 'AccountId',
}
)
</code></pre>
<hr />
<h4 id="reset_members_2">reset_members</h4>
<p>Change the membership to a new set, disregarding the existing membership. Be nice and
pass <code>members</code> pre-sorted.</p>
<p>May only be called from <code>T::ResetOrigin</code>.</p>
<h5 id="attributes_206">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>members</td>
<td><code>Vec&lt;T::AccountId&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="python_225">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'AllocationsOracles', 'reset_members', {'members': ['AccountId']}
)
</code></pre>
<hr />
<h4 id="change_key_2">change_key</h4>
<p>Swap out the sending member for some other key <code>new</code>.</p>
<p>May only be called from <code>Signed</code> origin of a current member.</p>
<p>Prime membership is passed from the origin account to <code>new</code>, if extant.</p>
<h5 id="attributes_207">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>new</td>
<td><code>T::AccountId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_226">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'AllocationsOracles', 'change_key', {'new': 'AccountId'}
)
</code></pre>
<hr />
<h4 id="set_prime_2">set_prime</h4>
<p>Set the prime member. Must be a current member.</p>
<p>May only be called from <code>T::PrimeOrigin</code>.</p>
<h5 id="attributes_208">Attributes</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>who</td>
<td><code>T::AccountId</code></td>
</tr>
</tbody>
</table>
<h5 id="python_227">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'AllocationsOracles', 'set_prime', {'who': 'AccountId'}
)
</code></pre>
<hr />
<h4 id="clear_prime_2">clear_prime</h4>
<p>Remove the prime member if it exists.</p>
<p>May only be called from <code>T::PrimeOrigin</code>.</p>
<h5 id="attributes_209">Attributes</h5>
<p>No attributes</p>
<h5 id="python_228">Python</h5>
<pre><code class="language-python">call = substrate.compose_call(
    'AllocationsOracles', 'clear_prime', {}
)
</code></pre>
<hr />
<h3 id="events_20">Events</h3>
<hr />
<h4 id="memberadded_2">MemberAdded</h4>
<p>The given member was added; see the transaction for who.</p>
<h5 id="attributes_210">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="memberremoved_2">MemberRemoved</h4>
<p>The given member was removed; see the transaction for who.</p>
<h5 id="attributes_211">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="membersswapped_2">MembersSwapped</h4>
<p>Two members were swapped; see the transaction for who.</p>
<h5 id="attributes_212">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="membersreset_2">MembersReset</h4>
<p>The membership was reset; see the transaction for who the new set is.</p>
<h5 id="attributes_213">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="keychanged_2">KeyChanged</h4>
<p>One of the members&amp;#x27; keys changed.</p>
<h5 id="attributes_214">Attributes</h5>
<p>No attributes</p>
<hr />
<h4 id="dummy_2">Dummy</h4>
<p>Phantom member, never used.</p>
<h5 id="attributes_215">Attributes</h5>
<p>No attributes</p>
<hr />
<h3 id="storage-functions_21">Storage functions</h3>
<hr />
<h4 id="members_3">Members</h4>
<p>The current membership, stored as an ordered Vec.</p>
<h5 id="python_229">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'AllocationsOracles', 'Members', []
)
</code></pre>
<h5 id="return-value_91">Return value</h5>
<pre><code class="language-python">['AccountId']
</code></pre>
<hr />
<h4 id="prime_3">Prime</h4>
<p>The current prime member, if one exists.</p>
<h5 id="python_230">Python</h5>
<pre><code class="language-python">call = substrate.query(
    'AllocationsOracles', 'Prime', []
)
</code></pre>
<h5 id="return-value_92">Return value</h5>
<pre><code class="language-python">'AccountId'
</code></pre>
<hr />
<h3 id="errors_15">Errors</h3>
<hr />
<h4 id="alreadymember_2">AlreadyMember</h4>
<p>Already a member.</p>
<hr />
<h4 id="notmember_3">NotMember</h4>
<p>Not a member.</p>
<hr />
<h4 id="toomanymembers_2">TooManyMembers</h4>
<p>Too many members.</p>
<hr />
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../litentry-parachain/" class="btn btn-neutral float-left" title="Litentry"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../origintrail-parachain/" class="btn btn-neutral float-right" title="OriginTrail Parachain">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/polkascan/py-substrate-metadata-docs" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../litentry-parachain/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../origintrail-parachain/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
